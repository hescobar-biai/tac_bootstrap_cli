# Feature: Template base_service.py - Generic CRUD Service Layer

## Metadata
issue_number: `115`
adw_id: `bad795f3`
issue_json: `{"number":115,"title":"Tarea 1.3: Template base_service.py","body":"/feature\n**Ganancia**: Servicio CRUD generico con generics tipados. Cada nueva entidad solo necesita `class ProductService(BaseService[ProductCreate, ProductUpdate, ProductResponse, ProductModel, Product])` para tener CRUD completo.\n\n**Instrucciones para el agente**:\n\n1. Crear template: `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_service.py.j2`\n2. Crear renderizado en raiz: `src/shared/application/base_service.py`\n2. Definir `BaseService` con generics: `BaseService[TCreate, TUpdate, TResponse, TModel, TDomain]`\n3. Metodos CRUD implementados:\n   - `create(data: TCreate, user_id: str | None = None) -> TResponse`\n   - `get_by_id(entity_id: str) -> TResponse` (raises 404 si no existe o state=2)\n   - `get_all(page: int, page_size: int, filters: dict, sort_by: str, sort_order: str) -> PaginatedResponse[TResponse]`\n   - `update(entity_id: str, data: TUpdate, user_id: str | None = None) -> TResponse`\n   - `delete(entity_id: str, user_id: str | None = None) -> bool` (soft delete)\n   - `hard_delete(entity_id: str) -> bool`\n4. Cada metodo debe:\n   - Excluir entidades con state=2 en queries\n   - Setear audit fields (created_by, updated_by)\n   - Incrementar version en updates\n5. Recibe `repository` en constructor via dependency injection\n\n**Criterios de aceptacion**:\n- La clase es generica y tipada correctamente\n- Soft delete seta state=2, no borra fisicamente\n- get_all soporta paginacion, filtros y ordenamiento\n- Raises HTTPException(404) cuando entidad no existe\n- documentacion adional /Volumes/MAc1/Celes/tac_bootstrap/ai_docs/doc/create-crud-entity"}`

## Feature Description

Create a generic, type-safe base service class that provides standard CRUD operations for all entities. This service layer acts as the business logic orchestrator between API routes and repository/persistence layer. Using Python generics, a single `BaseService` implementation provides complete CRUD functionality that entity-specific services inherit with zero duplication.

The template serves dual purpose:
1. **Jinja2 template** for FastAPI projects generated by TAC Bootstrap CLI
2. **Rendered reference implementation** for tac_bootstrap itself (as documentation example)

This feature eliminates 200+ lines of boilerplate per entity by providing a fully-functional service with:
- Type-safe generic operations
- Soft delete pattern (state=2 instead of physical deletion)
- Audit trail management (created_by, updated_by)
- Version control (optimistic locking support)
- Pagination with filtering and sorting
- Consistent error handling (HTTPException with proper status codes)

## User Story

As a **developer using TAC Bootstrap to generate a FastAPI project**
I want to **have a generic base service class with complete CRUD operations**
So that **I can create entity-specific services by simply inheriting and specifying types, without writing repetitive business logic**

## Problem Statement

When building CRUD APIs with DDD architecture, developers repeatedly write similar service layer code for each entity:
- **create()**: Validate data, create entity, set audit fields, save to repository
- **get_by_id()**: Fetch entity, check if exists/deleted, return response DTO
- **get_all()**: Apply filters, paginate, sort, map to response DTOs
- **update()**: Fetch entity, apply partial updates, increment version, save
- **delete()**: Soft delete by setting state=2 instead of physical deletion
- **hard_delete()**: Physical deletion for admin operations

Without a base service class, each entity requires duplicating:
- Generic CRUD logic (150+ lines per entity)
- Soft delete pattern implementation
- Audit field management (created_by, updated_by injection)
- Version increment logic
- Error handling (404 for missing entities, etc.)
- Pagination and filtering boilerplate
- DTO mapping (Entity → Response schema)

This leads to:
- Massive code duplication across services
- Inconsistent business logic patterns
- Easy to forget audit fields or version control
- Difficult to enforce soft delete everywhere
- Maintenance burden when changing common patterns

## Solution Statement

Create a generic `BaseService[TCreate, TUpdate, TResponse, TModel, TDomain]` class that:

**Design Approach:**
- **Thin business layer**: Delegates persistence to repository, validation to Pydantic/FastAPI
- **Type safety**: Python generics ensure compile-time type checking
- **Framework-agnostic domain**: Service works with any repository implementation
- **Separation of concerns**:
  - Service = business logic (audit, versioning, soft delete)
  - Repository = persistence (queries, transactions)
  - Routes = authorization, request validation
  - Schemas = type validation

**Generic Type Parameters:**
- `TCreate`: Pydantic schema for creation (e.g., ProductCreate)
- `TUpdate`: Pydantic schema for updates (e.g., ProductUpdate)
- `TResponse`: Pydantic schema for responses (e.g., ProductResponse)
- `TModel`: ORM model class (e.g., ProductModel for SQLAlchemy)
- `TDomain`: Domain entity class (e.g., Product)

**Core Methods:**

1. **create(data: TCreate, user_id: str | None = None) -> TResponse**
   - Convert TCreate schema to TDomain entity
   - Set created_by/updated_by to user_id (None if system operation)
   - Call repository.create()
   - Return TResponse

2. **get_by_id(entity_id: str) -> TResponse**
   - Call repository.get_by_id()
   - Raise HTTPException(404) if not found or state=2 (deleted)
   - Return TResponse

3. **get_all(page: int, page_size: int, filters: dict, sort_by: str, sort_order: str) -> PaginatedResponse[TResponse]**
   - Pass filters/sorting to repository.get_all() (repository validates column names)
   - Repository automatically excludes state=2 entities
   - Return PaginatedResponse with items, total, page info

4. **update(entity_id: str, data: TUpdate, user_id: str | None = None) -> TResponse**
   - Fetch entity via get_by_id() (ensures exists and not deleted)
   - Apply non-None fields from TUpdate
   - Set updated_by = user_id
   - Increment version (explicit version control)
   - Call repository.update()
   - Return TResponse

5. **delete(entity_id: str, user_id: str | None = None) -> bool**
   - Fetch entity via get_by_id()
   - Set state = 2 (soft delete)
   - Set updated_by = user_id
   - Call repository.update()
   - Return True

6. **hard_delete(entity_id: str) -> bool**
   - Fetch entity via repository.get_by_id() (even if state=2)
   - Raise HTTPException(404) if not found
   - Call repository.delete() (physical deletion)
   - Return True

**Transaction Management:**
- Repository handles transactions
- Each repository method is atomic
- Service keeps clean, database-agnostic

**Error Handling:**
- Raise HTTPException(404) for missing/deleted entities
- Repository raises ValueError for invalid filters/sort columns → caught and converted to HTTPException(400)

**PaginatedResponse Structure:**
```python
PaginatedResponse[T]:
  items: list[T]
  total: int
  page: int
  page_size: int
  total_pages: int
```

## Relevant Files

### Existing Files
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_entity.py.j2`: Domain entity template (reference for Entity class)
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_schema.py.j2`: Schema template (reference for TCreate, TUpdate, TResponse)
- `src/shared/domain/base_entity.py`: Rendered entity (shows Entity with state, version, audit fields)
- `src/shared/domain/base_schema.py`: Rendered schemas (BaseCreate, BaseUpdate, BaseResponse)
- `ai_docs/doc/create-crud-entity/WORKFLOW.md`: Complete CRUD entity workflow documentation
- `config.yml`: Project configuration (framework="none", language="python")

### New Files
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_service.py.j2`: Jinja2 template for base service (MAIN DELIVERABLE)
- `src/shared/application/base_service.py`: Rendered service for reference (dogfooding)

## Implementation Plan

### Phase 1: Foundation
1. Study base_entity.py and base_schema.py to understand field patterns
2. Review auto-resolved clarifications for design decisions
3. Design PaginatedResponse generic class
4. Create directory structure: `src/shared/application/`

### Phase 2: Core Implementation
1. Create `base_service.py.j2` template with imports
2. Define PaginatedResponse[T] generic class
3. Define BaseService[TCreate, TUpdate, TResponse, TModel, TDomain] generic class
4. Implement constructor with dependency injection
5. Implement CRUD methods: create, get_by_id, get_all, update, delete, hard_delete
6. Add comprehensive IDK docstrings following established pattern
7. Include usage examples in module docstring

### Phase 3: Integration
1. Render template to `src/shared/application/base_service.py`
2. Validate template renders without Jinja2 errors
3. Verify imports and type hints are valid Python
4. Run validation commands

## Step by Step Tasks

### Task 1: Create Template File and Imports
- Create file: `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_service.py.j2`
- Add module-level docstring with IDK pattern
- Import dependencies:
  - `from typing import Generic, TypeVar, Type`
  - `from uuid import UUID`
  - `from fastapi import HTTPException`
  - Base schema imports (reference only, won't execute in this project)

### Task 2: Define Generic Type Variables
- Define 5 TypeVars:
  - `TCreate = TypeVar('TCreate')` - Create schema type
  - `TUpdate = TypeVar('TUpdate')` - Update schema type
  - `TResponse = TypeVar('TResponse')` - Response schema type
  - `TModel = TypeVar('TModel')` - ORM model type
  - `TDomain = TypeVar('TDomain')` - Domain entity type

### Task 3: Define PaginatedResponse Class
- Create generic class `PaginatedResponse[T]`
- Define fields:
  - `items: list[T]` - List of response items
  - `total: int` - Total count of items
  - `page: int` - Current page number
  - `page_size: int` - Items per page
  - `total_pages: int` - Total number of pages
- Add comprehensive IDK docstring
- Include usage example

### Task 4: Define BaseService Class Signature
- Create generic class: `class BaseService(Generic[TCreate, TUpdate, TResponse, TModel, TDomain])`
- Add comprehensive module-level IDK docstring explaining:
  - Responsibility: Business logic orchestration for CRUD operations
  - Invariants: Soft delete, audit fields, version control
  - Usage pattern with inheritance example
- Define `__init__` method accepting repository via dependency injection

### Task 5: Implement create() Method
- Signature: `def create(self, data: TCreate, user_id: str | None = None) -> TResponse`
- Convert TCreate to TDomain entity
- Set created_by = user_id, updated_by = user_id
- Call repository.create()
- Return TResponse
- Add IDK docstring with Responsibility, Invariants, Failure Modes

### Task 6: Implement get_by_id() Method
- Signature: `def get_by_id(self, entity_id: str) -> TResponse`
- Call repository.get_by_id(entity_id)
- If not found or state=2: raise HTTPException(404, detail="Entity not found")
- Return TResponse
- Add comprehensive IDK docstring

### Task 7: Implement get_all() Method
- Signature: `def get_all(self, page: int, page_size: int, filters: dict, sort_by: str, sort_order: str) -> PaginatedResponse[TResponse]`
- Pass filters/sorting to repository.get_all()
- Repository excludes state=2 and validates columns (raises ValueError → HTTPException(400))
- Map results to PaginatedResponse
- Calculate total_pages = ceil(total / page_size)
- Return PaginatedResponse
- Add IDK docstring explaining filter passthrough pattern

### Task 8: Implement update() Method
- Signature: `def update(self, entity_id: str, data: TUpdate, user_id: str | None = None) -> TResponse`
- Fetch entity via get_by_id() (ensures exists and not deleted)
- Apply non-None fields from data
- Set updated_by = user_id
- Increment version += 1
- Call repository.update()
- Return TResponse
- Add IDK docstring

### Task 9: Implement delete() Method (Soft Delete)
- Signature: `def delete(self, entity_id: str, user_id: str | None = None) -> bool`
- Fetch entity via get_by_id()
- Set state = "2" or state = 2 (depending on entity field type)
- Set updated_by = user_id
- Call repository.update()
- Return True
- Add IDK docstring explaining soft delete pattern

### Task 10: Implement hard_delete() Method
- Signature: `def hard_delete(self, entity_id: str) -> bool`
- Call repository.get_by_id(entity_id, include_deleted=True) or similar
- Raise HTTPException(404) if not found
- Call repository.delete()
- Return True
- Add IDK docstring with warning about physical deletion

### Task 11: Render Template to src/shared/application/
- Create directory `src/shared/application/` if doesn't exist
- Render `base_service.py.j2` to `src/shared/application/base_service.py`
- Verify template rendering produces valid Python syntax
- Note: FastAPI/HTTPException imports are reference-only (framework="none" in this project)

### Task 12: Validation
- Verify template renders without Jinja2 errors
- Check Python syntax is valid
- Run validation commands (tests, lint, type check, smoke test)

## Testing Strategy

### Unit Tests
No unit tests required at this phase. Service template is validated through:
1. Successful rendering without Jinja2 errors
2. Valid Python syntax in rendered file
3. Type hints validated by mypy
4. Manual inspection of generated code

### Edge Cases
- **user_id=None**: Allow None for system/anonymous operations
- **state=2 filtering**: Repository excludes deleted entities automatically
- **Empty filters dict**: Repository handles empty filters (returns all)
- **Invalid sort column**: Repository validates and raises ValueError
- **Non-existent entity**: Raises HTTPException(404)
- **hard_delete on deleted**: Should succeed (removes even if state=2)
- **Version increment**: Explicit in update() for framework-agnostic pattern

## Acceptance Criteria

- [ ] Template file `base_service.py.j2` created in `tac_bootstrap_cli/tac_bootstrap/templates/shared/`
- [ ] Rendered file `base_service.py` exists in `src/shared/application/`
- [ ] PaginatedResponse[T] generic class defined with 5 fields
- [ ] BaseService generic class with 5 type parameters: TCreate, TUpdate, TResponse, TModel, TDomain
- [ ] Constructor accepts repository via dependency injection
- [ ] create() method sets created_by and updated_by from user_id parameter
- [ ] get_by_id() raises HTTPException(404) when entity not found or state=2
- [ ] get_all() returns PaginatedResponse with items, total, page, page_size, total_pages
- [ ] get_all() passes filters/sorting to repository (no validation in service)
- [ ] update() increments version explicitly before calling repository
- [ ] update() sets updated_by from user_id parameter
- [ ] delete() implements soft delete (sets state=2)
- [ ] hard_delete() raises HTTPException(404) if entity not found
- [ ] hard_delete() performs physical deletion via repository.delete()
- [ ] All methods include comprehensive IDK docstrings
- [ ] Module includes usage example showing inheritance pattern
- [ ] Template renders without Jinja2 errors
- [ ] Rendered file has valid Python syntax

## Validation Commands

Ejecutar todos los comandos para validar con cero regresiones:

- `python -c "import ast; ast.parse(open('src/shared/application/base_service.py').read()); print('Syntax valid')"` - Validate Python syntax
- `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` - Tests unitarios
- `cd tac_bootstrap_cli && uv run ruff check .` - Linting
- `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` - Type check
- `cd tac_bootstrap_cli && uv run tac-bootstrap --help` - Smoke test

## Notes

### Design Decisions (from Auto-Resolved Clarifications)

**Database Technology**
- Templates designed for SQLAlchemy with async support
- This project (framework="none") renders as reference example
- Repository interface is generic enough for any ORM

**Filter Validation**
- Service passes filters directly to repository
- Repository validates column names (has schema knowledge)
- Invalid filters raise ValueError → caught and converted to HTTPException(400)

**Type Coercion**
- No type coercion in BaseService
- Pydantic/FastAPI handles validation before service layer
- Service focuses on business logic, not type conversion

**user_id = None Behavior**
- Allow None for system/anonymous operations
- created_by/updated_by set to None indicates system action
- Provides flexibility for migrations, background jobs, health checks

**Version Increment**
- BaseService increments version explicitly in update()
- Makes version control framework-agnostic and explicit
- Repository can still add optimistic locking checks

**hard_delete() on Non-Existent Entity**
- Raise HTTPException(404) for consistency with get_by_id()
- Attempting to delete non-existent entity is error condition

**Authorization**
- No authorization checks in BaseService
- Authorization happens at route layer via FastAPI dependencies
- Service handles business logic only

**Transaction Management**
- Repository handles transactions
- Each repository method is atomic
- Service stays clean and database-agnostic
- Multi-operation transactions use UnitOfWork pattern (future enhancement)

**PaginatedResponse Structure**
- Standard pagination: items, total, page, page_size, total_pages
- Matches common REST API conventions
- Provides all info needed for UI navigation

**Simple Filters Only**
- filters dict supports exact match only
- Complex queries (joins, ranges, aggregations) use specialized repository methods
- Keeps BaseService generic for 80% use case

### Related Documentation
- Issue #111: base_entity.py template (domain layer)
- Issue #113: base_schema.py template (DTO layer)
- `ai_docs/doc/create-crud-entity/WORKFLOW.md`: Complete CRUD workflow
- Auto-resolved clarifications (embedded in issue)

### Future Enhancements
- Add async variants of CRUD methods
- Support for complex filtering (operators, ranges)
- Bulk operations (create_many, update_many)
- Transaction context manager for multi-operation atomicity
- Domain events publishing from service methods
- Caching layer integration
- Audit log generation
