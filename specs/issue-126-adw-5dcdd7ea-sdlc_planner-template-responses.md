# Feature: Template responses.py - Standardized Response Models

## Metadata
issue_number: `126`
adw_id: `5dcdd7ea`
issue_json: `{"number":126,"title":"Tarea 1.8: Template responses.py","body":"/feature\n/adw_sdlc_zte_iso\n**Ganancia**: Modelos de respuesta estandarizados. Todas las APIs retornan el mismo formato, facilitando integracion con frontends y documentacion OpenAPI.\n\n**Instrucciones para el agente**:\n\n1. Crear template: `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`\n2. Crear renderizado en raiz: `src/shared/infrastructure/responses.py`\n2. Modelos Pydantic:\n   - `PaginatedResponse[T]`:\n     - `data: list[T]`\n     - `total: int`\n     - `page: int` (1-indexed)\n     - `page_size: int` (1-100)\n     - `pages: int` (total_pages calculado)\n   - `SuccessResponse`:\n     - `success: bool = True`\n     - `message: str`\n   - `ErrorResponse`:\n     - `error: ErrorDetail`\n   - `ErrorDetail`:\n     - `type: str`\n     - `message: str`\n     - `details: dict | None`\n\n**Criterios de aceptacion**:\n- PaginatedResponse es generico (T)\n- `pages` se calcula como ceil(total / page_size)\n- page_size tiene validador: min=1, max=100\n- Response models are framework-agnostic but FastAPI-ready"}`

## Feature Description

Create a standardized response model system with Pydantic models for consistent API responses across all endpoints. This provides uniform data structures for pagination, success messages, and error handling, making frontend integration predictable and enabling automatic OpenAPI documentation generation.

The template serves dual purpose:
1. **Jinja2 template** at `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2` for projects generated by TAC Bootstrap CLI
2. **Rendered reference implementation** at `src/shared/infrastructure/responses.py` in the project root (documentation example)

This feature provides:
- Generic `PaginatedResponse[T]` for list endpoints with automatic page count calculation
- `SuccessResponse` for operations that return confirmation messages
- `ErrorResponse` and `ErrorDetail` for consistent error formatting (complements exceptions.py)
- Type-safe models with Pydantic validators
- OpenAPI schema generation out-of-the-box
- Framework-agnostic design (works with any Python web framework)

## User Story

As a **developer using TAC Bootstrap to generate a REST API project**
I want to **have pre-defined Pydantic models for common response patterns**
So that **all endpoints return consistent JSON structures without manual schema definition, and OpenAPI docs are automatically generated**

## Problem Statement

When building REST APIs, developers face repetitive response formatting challenges:

**Without Standardized Response Models:**
- **Inconsistent pagination**: Different endpoints use different field names (page vs page_number, total vs count, etc.)
- **Manual calculations**: Every list endpoint recalculates total_pages, handle edge cases differently
- **Type inconsistency**: page as string in one endpoint, int in another
- **No validation**: Invalid page sizes (0, negative, >100) not caught early
- **Hard to consume**: Frontend must handle different response shapes per endpoint
- **Poor OpenAPI docs**: Generic dicts don't generate useful schema documentation
- **Maintenance burden**: Changing response format requires updating every endpoint manually

**Typical Anti-Pattern (without response models):**
```python
# Each endpoint manually constructs pagination
@router.get("/products")
def list_products(page: int = 1, limit: int = 10):
    products = db.query(Product).offset((page-1)*limit).limit(limit).all()
    total = db.query(Product).count()
    return {
        "items": products,  # Inconsistent naming
        "total_count": total,
        "current_page": page,
        "per_page": limit,
        "total_pages": math.ceil(total / limit) if limit > 0 else 0  # Manual calculation
    }

# Different endpoint uses different field names
@router.get("/users")
def list_users(page: int = 1, page_size: int = 10):
    users = db.query(User).offset((page-1)*page_size).limit(page_size).all()
    count = db.query(User).count()
    return {
        "data": users,  # Different from "items"
        "total": count,  # Different from "total_count"
        "page": page,  # Different from "current_page"
        "page_size": page_size,  # Different from "per_page"
        "pages": count // page_size + (1 if count % page_size else 0)  # Different calculation logic
    }
```

**Problems with this approach:**
- Frontend needs different parsing logic per endpoint
- OpenAPI schema shows generic "object" instead of structured fields
- No validation on page/page_size values
- Easy to make off-by-one errors in pagination math
- Hard to test (no type safety)

## Solution Statement

Create Pydantic response models that enforce consistent structure across all endpoints:

**Design Approach:**
- **Generic PaginatedResponse[T]**: Type-safe pagination for list endpoints
- **Automated calculation**: `pages` field calculated automatically from total and page_size
- **Built-in validation**: page_size constrained to 1-100, page must be positive
- **Framework-agnostic**: Pure Pydantic models, no framework coupling
- **OpenAPI-friendly**: FastAPI auto-generates schemas from Pydantic models
- **Graceful edge cases**: Empty data for out-of-range pages, safe division for page calculation

**Core Components:**

1. **PaginatedResponse[T] (Generic Model)**
   - Type parameter `T` for any item type
   - Fields:
     - `data: list[T]` - The paginated items
     - `total: int` - Total count of items (all pages)
     - `page: int` - Current page number (1-indexed)
     - `page_size: int` - Items per page (1-100)
     - `pages: int` - Total pages (calculated: ceil(total/page_size))
   - Validators:
     - `page >= 1` (1-indexed pagination)
     - `1 <= page_size <= 100` (prevent abuse)
   - Edge cases:
     - `pages = 0` when `total = 0`
     - `pages = ceil(total/page_size)` otherwise
     - `data = []` when `page > pages` (graceful, no error)

2. **SuccessResponse**
   - For operations that confirm success with a message
   - Fields:
     - `success: bool = True` (always True)
     - `message: str` - Human-readable confirmation
   - Use cases:
     - POST/PUT/DELETE operations
     - Batch operations
     - Admin actions

3. **ErrorResponse**
   - For structured error responses (works with exceptions.py)
   - Fields:
     - `error: ErrorDetail` - Nested error object
   - Complements exception handlers from exceptions.py

4. **ErrorDetail**
   - Nested error structure
   - Fields:
     - `type: str` - Error type (e.g., "EntityNotFoundError", "validation_error")
     - `message: str` - Human-readable error message
     - `details: dict[str, Any] | None` - Optional structured details
   - Common types (documented in docstring):
     - "EntityNotFoundError", "DuplicateEntityError"
     - "validation_error", "authentication_error", "permission_error"
     - "business_rule_violation", "internal_error"

**Usage Example (After Implementation):**
```python
from pydantic import BaseModel
from src.shared.infrastructure.responses import PaginatedResponse, SuccessResponse

# Define your item schema
class ProductResponse(BaseModel):
    id: str
    name: str
    price: float

# Use in route with type safety
@router.get("/products", response_model=PaginatedResponse[ProductResponse])
def list_products(page: int = 1, page_size: int = 10):
    products = repository.find_all(page, page_size)
    total = repository.count()

    return PaginatedResponse(
        data=[ProductResponse.model_validate(p) for p in products],
        total=total,
        page=page,
        page_size=page_size
        # pages calculated automatically!
    )

# Success response
@router.delete("/products/{id}", response_model=SuccessResponse)
def delete_product(id: str):
    repository.delete(id)
    return SuccessResponse(message=f"Product {id} deleted successfully")
```

**Benefits:**
- **Consistency**: All list endpoints use same pagination structure
- **Type safety**: Generic T provides autocomplete and type checking
- **Automatic OpenAPI**: FastAPI generates detailed schema documentation
- **DRY**: No repeated pagination logic per endpoint
- **Validation**: Invalid page/page_size caught at request time
- **Frontend-friendly**: Predictable response shape across all endpoints

## Relevant Files

Files necessary for implementing this feature:

### Existing Templates (for reference patterns):
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2` - Shows Pydantic model structure, IDK docstrings, validators
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_schema.py.j2` - Shows BaseModel patterns and configuration
- `src/shared/infrastructure/exceptions.py` - Rendered template example showing dual creation pattern result

### New Files:
**Will be created by this feature:**

1. **Template:**
   - `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`
   - Jinja2 template with {{ config.project.name }} variables
   - Used by CLI to generate responses.py for new projects

2. **Rendered Reference:**
   - `src/shared/infrastructure/responses.py`
   - Rendered version using config.yml values
   - Serves as documentation/reference example
   - Not executed by tac-bootstrap CLI (framework="none")

### Configuration:
- `config.yml` - Contains project config values for template rendering (project.name, paths.app_root, etc.)

### Documentation References:
- `ai_docs/doc/create-crud-entity/` - Shows CRUD patterns where responses are used
- `PLAN_TAC_BOOTSTRAP.md` - Contains dual creation pattern rules and template conventions

## Implementation Plan

### Phase 1: Foundation
1. Create directory structure if not exists:
   - `tac_bootstrap_cli/tac_bootstrap/templates/shared/`
   - `src/shared/infrastructure/`

2. Study existing template patterns from `exceptions.py.j2` and `base_schema.py.j2`:
   - IDK docstring format
   - Jinja2 variable usage ({{ config.project.name }})
   - Module-level docstring with Responsibility/Invariants/Usage
   - Pydantic model configuration
   - Validator syntax

### Phase 2: Core Implementation - Jinja2 Template
1. Create `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`:
   - Module docstring with IDK tags
   - PaginatedResponse[T] generic model with computed pages field
   - SuccessResponse model
   - ErrorResponse and ErrorDetail models
   - Usage examples in docstrings

2. Template structure:
   ```python
   """
   IDK: api-responses, pagination, error-handling, http-responses

   Module: responses

   Responsibility: [...]
   Invariants: [...]
   Usage Examples: [...]
   """

   from typing import Generic, TypeVar, Any
   from pydantic import BaseModel, Field, field_validator, computed_field
   from math import ceil

   T = TypeVar("T")

   class PaginatedResponse(BaseModel, Generic[T]): ...
   class SuccessResponse(BaseModel): ...
   class ErrorDetail(BaseModel): ...
   class ErrorResponse(BaseModel): ...
   ```

3. Ensure Jinja2 syntax for config values:
   - Comment noting project generation: `# Generated by {{ config.project.name }}`
   - Minimal Jinja2 logic (keep template simple)

### Phase 3: Integration - Rendered Reference File
1. Read `config.yml` to get actual values:
   - project.name = "tac-bootstrap"
   - project.language = "python"
   - project.framework = "none"

2. Render template with config values:
   - Replace `{{ config.project.name }}` → "tac-bootstrap"
   - Add header comment noting this is reference implementation

3. Create `src/shared/infrastructure/responses.py`:
   - Render the .j2 template with config.yml values
   - Add comment at top: "# Reference implementation - generated from responses.py.j2 template"
   - Include note: "# This file serves as documentation for the responses.py template output"
   - Include note: "# Not used by the CLI itself (tac-bootstrap has framework=\"none\")"

4. Verify dual creation:
   - Template file exists: `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`
   - Rendered file exists: `src/shared/infrastructure/responses.py`
   - Both files are consistent in structure

## Step by Step Tasks

IMPORTANTE: Ejecutar cada paso en orden.

### Task 1: Create Jinja2 Template Structure
- Create directory `tac_bootstrap_cli/tac_bootstrap/templates/shared/` if not exists
- Create file `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`
- Add module-level docstring with IDK tags:
  - IDK: api-responses, pagination, error-handling, http-responses, openapi-schema
  - Module: responses
  - Responsibility section explaining standardized response models
  - Key Components listing all response classes
  - Invariants: pagination rules (1-indexed, page_size 1-100, automatic pages calculation)
  - Usage Examples showing PaginatedResponse, SuccessResponse, ErrorResponse
  - Collaborators: Pydantic, FastAPI routes, service layer
  - Failure Modes: what happens with invalid pagination parameters
  - Related Docs references

### Task 2: Implement PaginatedResponse[T] Generic Model
- Define type variable: `T = TypeVar("T")`
- Define `PaginatedResponse(BaseModel, Generic[T])` with:
  - `data: list[T]` - The paginated items
  - `total: int` - Total count across all pages (Field with ge=0 constraint)
  - `page: int` - Current page number (Field with ge=1 constraint for 1-indexed)
  - `page_size: int` - Items per page (Field with ge=1, le=100 constraints)
  - `pages: int` - Computed field using @computed_field decorator
- Implement `pages` calculation as computed_field:
  ```python
  @computed_field
  @property
  def pages(self) -> int:
      if self.total == 0:
          return 0
      return ceil(self.total / self.page_size)
  ```
- Add comprehensive docstring:
  - Explain generic type parameter T
  - Document 1-indexed pagination
  - Explain automatic pages calculation
  - Document validators (page_size 1-100, page >= 1)
  - Show usage example with ProductResponse type
  - Explain edge cases (empty data, page > pages returns empty list gracefully)
- Add model_config for strict mode:
  ```python
  model_config = {"arbitrary_types_allowed": True}
  ```

### Task 3: Implement SuccessResponse Model
- Define `SuccessResponse(BaseModel)` with:
  - `success: bool = True` - Always True (Field with default)
  - `message: str` - Human-readable confirmation message
- Add docstring:
  - Explain use cases (POST/PUT/DELETE confirmations)
  - Show usage example with delete operation
  - Note that success field is always True (redundant but explicit for API consumers)

### Task 4: Implement ErrorDetail and ErrorResponse Models
- Define `ErrorDetail(BaseModel)` with:
  - `type: str` - Error type identifier (Field with min_length=1)
  - `message: str` - Human-readable error message (Field with min_length=1)
  - `details: dict[str, Any] | None = None` - Optional structured error details
- Add ErrorDetail docstring:
  - List common error types (from exceptions.py):
    - "EntityNotFoundError", "DuplicateEntityError"
    - "DomainValidationError", "UnauthorizedError", "ForbiddenError"
    - "BusinessRuleError", "InternalServerError"
  - Explain details field usage (validation errors, field-specific messages)
  - Show example with nested validation errors

- Define `ErrorResponse(BaseModel)` with:
  - `error: ErrorDetail` - Nested error object
- Add ErrorResponse docstring:
  - Explain this works with exceptions.py handlers
  - Show usage example matching exception handler format
  - Note consistent format across all errors

### Task 5: Add Usage Examples to Module Docstring
- Expand module docstring with complete usage examples:
  1. **Pagination example**:
     ```python
     # Define item schema
     class ProductResponse(BaseModel):
         id: str
         name: str
         price: float

     # Use in route
     @router.get("/products", response_model=PaginatedResponse[ProductResponse])
     def list_products(page: int = 1, page_size: int = 10):
         products = repository.find_all(page, page_size)
         total = repository.count()
         return PaginatedResponse(
             data=[ProductResponse.model_validate(p) for p in products],
             total=total,
             page=page,
             page_size=page_size
         )
     ```

  2. **Success response example**:
     ```python
     @router.delete("/products/{id}", response_model=SuccessResponse)
     def delete_product(id: str):
         repository.delete(id)
         return SuccessResponse(message=f"Product {id} deleted")
     ```

  3. **Error response example** (auto-generated by exception handlers):
     ```python
     # Exception handlers return ErrorResponse automatically
     # Frontend receives:
     {
       "error": {
         "type": "EntityNotFoundError",
         "message": "Product with id 'abc123' not found",
         "details": {"entity_type": "Product", "entity_id": "abc123"}
       }
     }
     ```

### Task 6: Add Jinja2 Template Variables
- Add header comment with Jinja2 variable:
  ```python
  # Generated by {{ config.project.name }} - Standardized Response Models
  # This template provides consistent API response structures
  ```

- Keep template minimal - no conditional logic needed
- All imports are standard Python/Pydantic (no framework-specific imports)

### Task 7: Create Rendered Reference Implementation
- Create directory `src/shared/infrastructure/` if not exists
- Read `config.yml` to extract values:
  - project.name = "tac-bootstrap"
  - project.framework = "none"
- Render the template with these values:
  - Replace `{{ config.project.name }}` → "tac-bootstrap"
- Create `src/shared/infrastructure/responses.py`:
  - Add header comments:
    ```python
    # Reference implementation - generated from responses.py.j2 template
    # This file serves as documentation for the responses.py template output
    # Not used by the CLI itself (tac-bootstrap has framework="none")
    ```
  - Include full rendered template content below header

### Task 8: Verify Dual Creation Pattern
- Verify both files exist:
  - Template: `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`
  - Rendered: `src/shared/infrastructure/responses.py`
- Compare structure consistency:
  - Same models in both files (PaginatedResponse, SuccessResponse, ErrorResponse, ErrorDetail)
  - Same field definitions
  - Same validators and computed fields
  - Template has Jinja2 syntax, rendered has actual values
- Read both files to confirm they're properly formatted
- Verify imports are correct (typing, pydantic, math.ceil)

### Task 9: Validation Commands
- Execute all validation commands to ensure zero regressions:
  - Run tests: `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short`
  - Run linting: `cd tac_bootstrap_cli && uv run ruff check .`
  - Run type checking: `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/`
  - Smoke test CLI: `cd tac_bootstrap_cli && uv run tac-bootstrap --help`
- Verify all commands pass without errors
- If any failures occur, fix issues before proceeding

## Testing Strategy

### Unit Tests

**Template File Tests** (if template rendering logic exists):
- Test that responses.py.j2 is valid Jinja2 syntax
- Test rendering with sample config values
- Verify output contains all response models
- Verify computed_field for pages calculation exists

**Model Instantiation Tests** (for future integration):
When responses.py is integrated into actual projects:
- Test PaginatedResponse with various types (ProductResponse, UserResponse)
- Test page calculation edge cases:
  - `total=0` → `pages=0`
  - `total=10, page_size=10` → `pages=1`
  - `total=11, page_size=10` → `pages=2` (ceil division)
  - `total=100, page_size=1` → `pages=100`
- Test page_size validator:
  - `page_size=0` → ValidationError
  - `page_size=1` → Valid
  - `page_size=100` → Valid
  - `page_size=101` → ValidationError
- Test page validator:
  - `page=0` → ValidationError
  - `page=1` → Valid
  - `page=999` → Valid (no upper bound, returns empty data gracefully)
- Test SuccessResponse instantiation
- Test ErrorResponse with ErrorDetail nested structure

### Edge Cases

**Pagination Edge Cases:**
- Empty dataset: `total=0, data=[], pages=0`
- Single item: `total=1, page_size=10, pages=1`
- Exact page boundary: `total=20, page_size=10, pages=2`
- Page beyond total_pages: `page=10, pages=2` → returns empty data (no error)
- Large datasets: `total=10000, page_size=100, pages=100`
- page_size=1: `total=5, page_size=1, pages=5`

**Validator Edge Cases:**
- Negative total: Should fail validation (total: int = Field(ge=0))
- Negative page: Should fail validation (page: int = Field(ge=1))
- page_size=0: Should fail validation
- page_size=101: Should fail validation
- Non-integer values (Pydantic coercion): "10" → 10 (allowed)

**Generic Type Parameter:**
- PaginatedResponse[ProductResponse] with ProductResponse items
- PaginatedResponse[UserResponse] with UserResponse items
- PaginatedResponse[str] with plain string items
- PaginatedResponse[dict] with dict items

**ErrorResponse Structure:**
- ErrorDetail with None details
- ErrorDetail with empty dict details {}
- ErrorDetail with nested dict details {"field": "email", "errors": [...]}
- Long error messages (no truncation)

**Template Rendering Edge Cases:**
- Config values with special characters
- Missing config values (use defaults)

## Acceptance Criteria

1. **Template File Exists:**
   - File created at `tac_bootstrap_cli/tac_bootstrap/templates/shared/responses.py.j2`
   - Valid Jinja2 syntax (no syntax errors)
   - Contains module-level docstring with IDK tags
   - Includes Responsibility, Invariants, Usage Examples sections

2. **Rendered File Exists:**
   - File created at `src/shared/infrastructure/responses.py`
   - Header comments indicate reference implementation
   - All Jinja2 variables replaced with config.yml values
   - All imports present (typing, pydantic, math)

3. **PaginatedResponse[T] Model:**
   - Generic type parameter T defined with TypeVar
   - Fields: data: list[T], total: int, page: int, page_size: int, pages: int
   - pages is computed_field with @property decorator
   - pages calculation: `ceil(total / page_size)` with 0 handling
   - Validators: page >= 1, 1 <= page_size <= 100, total >= 0
   - Comprehensive docstring explaining generics, 1-indexed pagination, edge cases
   - Usage example in docstring with ProductResponse type

4. **SuccessResponse Model:**
   - Fields: success: bool = True, message: str
   - success field has default value True
   - Docstring explains use cases (POST/PUT/DELETE confirmations)
   - Usage example in docstring

5. **ErrorDetail Model:**
   - Fields: type: str, message: str, details: dict[str, Any] | None
   - All string fields have min_length validation
   - details field allows None
   - Docstring lists common error types
   - Usage example showing nested structure

6. **ErrorResponse Model:**
   - Field: error: ErrorDetail
   - Docstring explains integration with exceptions.py
   - Usage example matches exception handler format

7. **Documentation Quality:**
   - Module docstring follows IDK format from existing templates
   - Each model has comprehensive docstring
   - Usage examples cover all models
   - Edge cases documented (page > pages, total=0, etc.)
   - Comments explain design decisions

8. **Dual Creation Consistency:**
   - Template and rendered files have same structure
   - Only difference is Jinja2 variables vs actual values
   - Both files are properly formatted and readable
   - Both files have proper imports (typing, pydantic, math.ceil)

9. **Type Safety:**
   - Generic PaginatedResponse[T] provides type checking
   - All fields have explicit type annotations
   - dict[str, Any] for ErrorDetail.details (not just dict)
   - Validators use Pydantic Field constraints

10. **Validation Commands Pass:**
    - `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` → 0 failures
    - `cd tac_bootstrap_cli && uv run ruff check .` → no linting errors
    - `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` → no type errors
    - `cd tac_bootstrap_cli && uv run tac-bootstrap --help` → displays help without errors

## Validation Commands

Ejecutar todos los comandos para validar con cero regresiones:

- `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` - Tests unitarios
- `cd tac_bootstrap_cli && uv run ruff check .` - Linting
- `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` - Type check
- `cd tac_bootstrap_cli && uv run tac-bootstrap --help` - Smoke test

## Notes

**Design Decisions:**

1. **Why computed_field for pages instead of validator?**
   - Cleaner API: users don't pass pages, it's calculated automatically
   - Immutable: can't be overridden by accident
   - Type-safe: computed_field integrates with Pydantic type checking
   - OpenAPI: auto-documented as read-only calculated field

2. **Why 1-indexed pagination (page >= 1)?**
   - User-facing APIs typically use 1-indexed (page 1, 2, 3...)
   - Matches database OFFSET calculation: `(page-1) * page_size`
   - More intuitive for non-technical users
   - Standard in REST API pagination

3. **Why page_size max of 100?**
   - Prevents abuse (requesting 1M items crashes server)
   - Reasonable limit for UI pagination
   - Can be adjusted per project if needed (template can include config variable)
   - Common industry standard

4. **Why allow page > pages (return empty data)?**
   - More graceful than error (avoids 400 Bad Request)
   - Client can detect via pages field
   - Standard REST API pattern
   - Simplifies client logic (no need to validate page before request)

5. **Why separate ErrorDetail and ErrorResponse?**
   - Consistent with exceptions.py error format
   - Allows nesting error information
   - Matches JSON structure: `{"error": {"type": "...", "message": "...", "details": {...}}}`
   - Easier to extend with additional metadata (request_id, timestamp, etc.)

6. **Why Generic[T] instead of Any?**
   - Type safety: IDE autocomplete for data field items
   - Validation: Pydantic validates each item against T schema
   - OpenAPI: FastAPI generates specific schema (not generic object)
   - Documentation: response_model=PaginatedResponse[ProductResponse] is self-documenting

7. **Why SuccessResponse.success always True?**
   - Explicit over implicit (API consumer knows it succeeded)
   - Consistent structure (error has error field, success has success field)
   - Some clients check success field programmatically
   - Redundant but conventional in REST APIs

**Future Enhancements (not in this task):**

- Add next_page, prev_page URL fields to PaginatedResponse (requires URL construction)
- Add has_next, has_prev boolean helpers
- Add request_id to ErrorResponse for tracing
- Add timestamp to responses
- Add metadata field to PaginatedResponse for extra info (filters, sort, etc.)
- Add CursorPaginatedResponse for cursor-based pagination (alternative to offset)
- Add internationalization support for error messages
- Add response envelope wrapper (optional, controversial design)

**Integration Points:**

- **Routes**: Will use response_model=PaginatedResponse[ItemSchema] in list endpoints
- **Services**: Return model instances instead of raw dicts
- **Exception handlers**: Already return ErrorResponse format (from exceptions.py)
- **OpenAPI**: FastAPI auto-generates schema from response_model
- **Frontend**: Can generate TypeScript types from OpenAPI schema

**Related Files to Update Later:**

- `templates/capabilities/crud_basic/routes.py.j2`: Use PaginatedResponse in GET /items endpoints
- `templates/capabilities/crud_basic/service.py.j2`: Return response model instances
- Main.py template (if exists): Document response_model usage in example route

**Performance Considerations:**

- Computed pages field has minimal overhead (one division + ceil)
- No database calls in models (pure data structures)
- Pydantic validation is fast (C extension in Pydantic v2)
- Generic types have no runtime cost (type erasure)

**Security Considerations:**

- ErrorDetail.details should not contain sensitive data (passwords, tokens)
- total field could leak information (e.g., total users count) - consider permissions
- Error messages should be user-friendly but not reveal internal structure
- page_size limit prevents DOS via excessive pagination requests

**Documentation Reminders:**

- Document that PaginatedResponse works with any Pydantic model as T
- Explain difference between 1-indexed (user-facing) and 0-indexed (database OFFSET)
- Show example of converting page/page_size to database OFFSET/LIMIT
- Document edge case handling (page > pages, total=0)
- Add examples showing FastAPI route integration with response_model parameter
