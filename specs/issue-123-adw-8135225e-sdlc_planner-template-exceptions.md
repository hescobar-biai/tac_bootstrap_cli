# Feature: Template exceptions.py - Typed Exception System with HTTP Handlers

## Metadata
issue_number: `123`
adw_id: `8135225e`
issue_json: `{"number":123,"title":"Tarea 1.7: Template exceptions.py","body":"/feature\n**Ganancia**: Exceptions tipadas con HTTP handlers pre-registrados. Errores consistentes en toda la API sin repetir try/except en cada endpoint.\n\n**Instrucciones para el agente**:\n\n1. Crear template: `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`\n2. Crear renderizado en raiz: `src/shared/infrastructure/exceptions.py`\n2. Clases de exception:\n   - `EntityNotFoundError(entity_type: str, entity_id: str)` → 404\n   - `DuplicateEntityError(entity_type: str, field: str, value: str)` → 409\n   - `ValidationError(message: str, details: dict)` → 422\n   - `UnauthorizedError(message: str)` → 401\n   - `ForbiddenError(message: str)` → 403\n   - `BusinessRuleError(message: str)` → 400\n3. FastAPI exception handlers:\n   - `register_exception_handlers(app: FastAPI)` que registra handler para cada exception\n   - Cada handler retorna JSON con `{\"error\": {\"type\": \"...\", \"message\": \"...\", \"details\": {...}}}`\n\n**Criterios de aceptacion**:\n- Cada exception mapea a un HTTP status code especifico\n- Los handlers retornan formato JSON consistente\n- `register_exception_handlers()` se puede llamar en main.py"}`

## Feature Description

Create a comprehensive exception system with typed domain exceptions and pre-configured FastAPI exception handlers that provide consistent error responses across all API endpoints. This eliminates repetitive try/except blocks and ensures uniform error formatting throughout the application.

The template serves dual purpose:
1. **Jinja2 template** at `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2` for FastAPI projects generated by TAC Bootstrap CLI
2. **Rendered reference implementation** at `src/shared/infrastructure/exceptions.py` in the project root (documentation example)

This feature provides:
- Domain-specific exception classes mapped to HTTP status codes
- Centralized exception handling via FastAPI's exception handler system
- Consistent JSON error format: `{"error": {"type": "...", "message": "...", "details": {...}}}`
- Single registration function to wire all handlers to FastAPI app
- Clear exception hierarchy with APIException base class
- Security-conscious error messages (no implementation details leaked)

## User Story

As a **developer using TAC Bootstrap to generate a FastAPI project**
I want to **have pre-defined domain exceptions with automatic HTTP handler registration**
So that **I can raise typed exceptions in my business logic and get consistent error responses without writing try/except blocks in every endpoint**

## Problem Statement

When building REST APIs with FastAPI, developers face repetitive error handling challenges:

**Without Centralized Exception System:**
- **Every endpoint needs try/except**: Wrapping service calls with exception handling
- **Inconsistent error responses**: Different endpoints return different JSON formats
- **Manual status code mapping**: Developers must remember which exception → which HTTP code
- **Duplicate error formatting**: Same error→JSON logic repeated everywhere
- **Hard to maintain**: Changes to error format require updating every endpoint
- **Security risks**: Accidentally leaking stack traces or implementation details
- **Lost context**: Generic exceptions lose domain meaning (EntityNotFoundError vs HTTPException(404))

**Typical Anti-Pattern (without exception system):**
```python
# Every route repeats this pattern
@router.get("/products/{product_id}")
def get_product(product_id: str, db: Session = Depends(get_db)):
    try:
        product = service.get_by_id(product_id)
        return product
    except EntityNotFoundError as e:
        return JSONResponse({"error": str(e)}, status_code=404)
    except ValidationError as e:
        return JSONResponse({"error": str(e)}, status_code=422)
    except Exception as e:
        return JSONResponse({"error": "Internal error"}, status_code=500)
```

**Problems with this approach:**
- 8+ lines of error handling per endpoint
- Easy to miss an exception type
- Inconsistent error response formats across endpoints
- Maintenance nightmare when format changes
- Security risk: generic `Exception` might leak sensitive data

## Solution Statement

Create a typed exception system with automatic FastAPI handler registration:

**Design Approach:**
- **Base exception class**: `APIException(Exception)` for all domain exceptions
- **Domain-specific exceptions**: Semantic exceptions that describe business failures
- **HTTP status mapping**: Each exception maps to appropriate HTTP status code
- **Centralized handlers**: FastAPI exception handlers registered once in main.py
- **Consistent format**: All errors return `{"error": {"type": "...", "message": "...", "details": {...}}}`
- **Security by default**: Generic handler sanitizes unexpected exceptions
- **Zero boilerplate**: Raise exceptions anywhere, handlers format responses automatically

**Exception Hierarchy:**
```
Exception (Python builtin)
  └─ APIException (base class for all domain exceptions)
       ├─ EntityNotFoundError → 404
       ├─ DuplicateEntityError → 409
       ├─ DomainValidationError → 422
       ├─ UnauthorizedError → 401
       ├─ ForbiddenError → 403
       └─ BusinessRuleError → 400
```

**Core Components:**

1. **APIException (Base Class)**
   - Base for all domain exceptions
   - Stores type, message, details
   - Enables catch-all handling

2. **Domain Exception Classes:**
   - **EntityNotFoundError(entity_type, entity_id)** → 404
     - Raised when entity doesn't exist or state=2 (soft deleted)
     - Example: `EntityNotFoundError("Product", "abc123")`

   - **DuplicateEntityError(entity_type, field, value)** → 409
     - Raised when unique constraint violated (email, SKU, etc.)
     - Example: `DuplicateEntityError("User", "email", "john@example.com")`

   - **DomainValidationError(message, details)** → 422
     - Raised for domain-level validation failures (not Pydantic schema validation)
     - Example: `DomainValidationError("Invalid price", {"price": -10, "min": 0})`
     - Note: Renamed from ValidationError to avoid conflicts with Pydantic

   - **UnauthorizedError(message)** → 401
     - Raised when authentication missing or invalid
     - Example: `UnauthorizedError("Token expired")`

   - **ForbiddenError(message)** → 403
     - Raised when authenticated but insufficient permissions
     - Example: `ForbiddenError("User role 'viewer' cannot delete products")`

   - **BusinessRuleError(message)** → 400
     - Raised when business rule violated (e.g., can't delete product with active orders)
     - Example: `BusinessRuleError("Cannot delete product with 5 active orders")`

3. **Exception Handlers:**
   - Each exception gets dedicated handler
   - Handlers return JSONResponse with consistent format
   - Generic Exception handler for unexpected errors (500 status)

4. **register_exception_handlers(app: FastAPI)**
   - Single function registers all handlers
   - Called once in main.py: `register_exception_handlers(app)`
   - Wires exception classes to handler functions

**Error Response Format:**
```json
{
  "error": {
    "type": "EntityNotFoundError",
    "message": "Product with id 'abc123' not found",
    "details": {
      "entity_type": "Product",
      "entity_id": "abc123"
    }
  }
}
```

**Usage Example (After Implementation):**
```python
# In service layer - just raise the exception
class ProductService:
    def get_by_id(self, product_id: str) -> ProductResponse:
        entity = self.repository.get_by_id(product_id)
        if not entity or entity.state == 2:
            raise EntityNotFoundError("Product", product_id)
        return ProductResponse.model_validate(entity)

# In route - no try/except needed!
@router.get("/products/{product_id}")
def get_product(product_id: str, service: ProductService = Depends()):
    return service.get_by_id(product_id)  # Exception auto-handled → 404 JSON

# In main.py - one-time registration
from src.shared.infrastructure.exceptions import register_exception_handlers

app = FastAPI()
register_exception_handlers(app)
```

**Benefits:**
- **Zero boilerplate per endpoint**: No try/except in routes
- **Type-safe exception raising**: IDE autocomplete for exception classes
- **Consistent error format**: Frontend can parse errors predictably
- **Semantic exceptions**: `EntityNotFoundError` is clearer than `HTTPException(404)`
- **Single point of control**: Change error format once, applies everywhere
- **Security**: Generic exceptions sanitized automatically

## Relevant Files

Files necessary for implementing this feature:

### Existing Templates (for reference patterns):
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/database.py.j2` - Shows Jinja2 template structure, IDK docstrings, config variable usage
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_service.py.j2` - Shows how exceptions are raised in business logic (HTTPException usage to be replaced)
- `src/shared/infrastructure/database.py` - Rendered template example showing dual creation pattern result

### New Files:
**Will be created by this feature:**

1. **Template:**
   - `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`
   - Jinja2 template with {{ config.project.name }} variables
   - Used by CLI to generate exceptions.py for new projects

2. **Rendered Reference:**
   - `src/shared/infrastructure/exceptions.py`
   - Rendered version using config.yml values
   - Serves as documentation/reference example
   - Not executed by tac-bootstrap CLI (framework="none")

### Configuration:
- `config.yml` - Contains project config values for template rendering (project.name, paths.app_root, etc.)

### Documentation References:
- `ai_docs/doc/create-crud-entity/` - Shows CRUD patterns where exceptions are used
- `PLAN_TAC_BOOTSTRAP.md` - Contains dual creation pattern rules and template conventions

## Implementation Plan

### Phase 1: Foundation
1. Create directory structure if not exists:
   - `tac_bootstrap_cli/tac_bootstrap/templates/shared/`
   - `src/shared/infrastructure/`

2. Study existing template patterns from `database.py.j2`:
   - IDK docstring format
   - Jinja2 variable usage ({{ config.project.name }})
   - Module-level docstring with Responsibility/Invariants/Usage
   - Function-level docstrings with IDK tags

### Phase 2: Core Implementation - Jinja2 Template
1. Create `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`:
   - Module docstring with IDK tags
   - APIException base class
   - 6 domain exception classes
   - Exception handler functions (one per exception + generic)
   - register_exception_handlers() function
   - Usage examples in docstrings

2. Template structure:
   ```python
   """
   IDK: exception-handling, error-responses, http-status-codes

   Module: exceptions

   Responsibility: [...]
   Invariants: [...]
   Usage Examples: [...]
   """

   from fastapi import FastAPI, Request
   from fastapi.responses import JSONResponse

   class APIException(Exception): ...
   class EntityNotFoundError(APIException): ...
   # ... other exceptions ...

   def register_exception_handlers(app: FastAPI): ...
   ```

3. Ensure Jinja2 syntax for config values:
   - Comment noting this is for FastAPI projects: `# Generated by {{ config.project.name }}`
   - Use conditional rendering if needed (see database.py.j2 async example)

### Phase 3: Integration - Rendered Reference File
1. Read `config.yml` to get actual values:
   - project.name = "tac-bootstrap"
   - project.language = "python"
   - project.framework = "none"

2. Render template with config values:
   - Replace `{{ config.project.name }}` → "tac-bootstrap"
   - Add header comment noting this is reference implementation

3. Create `src/shared/infrastructure/exceptions.py`:
   - Render the .j2 template with config.yml values
   - Add comment at top: "# Reference implementation - generated from exceptions.py.j2 template"
   - Include note: "# This file serves as documentation for the exceptions.py template output"
   - Include note: "# Not used by the CLI itself (tac-bootstrap has framework=\"none\")"

4. Verify dual creation:
   - Template file exists: `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`
   - Rendered file exists: `src/shared/infrastructure/exceptions.py`
   - Both files are consistent in structure

## Step by Step Tasks

IMPORTANTE: Ejecutar cada paso en orden.

### Task 1: Create Jinja2 Template Structure
- Create directory `tac_bootstrap_cli/tac_bootstrap/templates/shared/` if not exists
- Create file `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`
- Add module-level docstring with IDK tags:
  - IDK: exception-handling, error-responses, http-status-codes, fastapi-middleware
  - Module: exceptions
  - Responsibility section explaining the module's purpose
  - Key Components listing all exception classes and handlers
  - Invariants: error format consistency, status code mapping rules
  - Usage Examples showing how to raise exceptions and register handlers
  - Collaborators: FastAPI, service layer, routes
  - Failure Modes: what happens with unhandled exceptions
  - Related Docs references

### Task 2: Implement APIException Base Class
- Define `APIException(Exception)` with:
  - `__init__(self, message: str, details: dict | None = None)`
  - Store message and details as attributes
  - Include docstring with IDK tags explaining base class purpose
- This base enables catch-all handling and type checking

### Task 3: Implement Domain Exception Classes
- Implement 6 domain exceptions inheriting from APIException:
  1. **EntityNotFoundError(APIException)**:
     - `__init__(self, entity_type: str, entity_id: str)`
     - Construct message: f"{entity_type} with id '{entity_id}' not found"
     - Details: {"entity_type": entity_type, "entity_id": entity_id}
     - Docstring: explain 404 mapping, soft delete usage

  2. **DuplicateEntityError(APIException)**:
     - `__init__(self, entity_type: str, field: str, value: str)`
     - Message: f"{entity_type} with {field}='{value}' already exists"
     - Details: {"entity_type": entity_type, "field": field, "value": value}
     - Docstring: explain 409 mapping, unique constraint failures

  3. **DomainValidationError(APIException)**:
     - `__init__(self, message: str, details: dict | None = None)`
     - Use message as-is (allows custom validation messages)
     - Details: pass through (e.g., {"price": -10, "min": 0})
     - Docstring: explain 422 mapping, difference from Pydantic validation, why renamed

  4. **UnauthorizedError(APIException)**:
     - `__init__(self, message: str = "Authentication required")`
     - Message: use provided or default
     - Details: None (don't leak auth details)
     - Docstring: explain 401 mapping, authentication vs authorization

  5. **ForbiddenError(APIException)**:
     - `__init__(self, message: str = "Insufficient permissions")`
     - Message: use provided or default
     - Details: None (don't leak permission details)
     - Docstring: explain 403 mapping, when to use vs UnauthorizedError

  6. **BusinessRuleError(APIException)**:
     - `__init__(self, message: str, details: dict | None = None)`
     - Message and details: pass through
     - Docstring: explain 400 mapping, examples of business rule violations

### Task 4: Implement Exception Handler Functions
- Create handler function for each domain exception:
  - **entity_not_found_handler(request: Request, exc: EntityNotFoundError)**:
    - Status code: 404
    - Return JSONResponse with format: `{"error": {"type": "EntityNotFoundError", "message": exc.message, "details": exc.details}}`

  - **duplicate_entity_handler(request: Request, exc: DuplicateEntityError)**:
    - Status code: 409

  - **domain_validation_handler(request: Request, exc: DomainValidationError)**:
    - Status code: 422

  - **unauthorized_handler(request: Request, exc: UnauthorizedError)**:
    - Status code: 401

  - **forbidden_handler(request: Request, exc: ForbiddenError)**:
    - Status code: 403

  - **business_rule_handler(request: Request, exc: BusinessRuleError)**:
    - Status code: 400

- Create generic exception handler:
  - **generic_exception_handler(request: Request, exc: Exception)**:
    - Status code: 500
    - Message: "Internal server error" (don't leak details)
    - Details: {} (empty, security-conscious)
    - Type: "InternalServerError"

- Each handler function should:
  - Accept (request: Request, exc: ExceptionType) parameters
  - Extract type name from exception class: `type(exc).__name__`
  - Build error dict: `{"error": {"type": "...", "message": exc.message, "details": exc.details or {}}}`
  - Return JSONResponse(content=error_dict, status_code=STATUS_CODE)
  - Include docstring explaining handler purpose and status code

### Task 5: Implement register_exception_handlers() Function
- Define `register_exception_handlers(app: FastAPI) -> None`:
  - Call `app.add_exception_handler(ExceptionClass, handler_function)` for each exception:
    - EntityNotFoundError → entity_not_found_handler
    - DuplicateEntityError → duplicate_entity_handler
    - DomainValidationError → domain_validation_handler
    - UnauthorizedError → unauthorized_handler
    - ForbiddenError → forbidden_handler
    - BusinessRuleError → business_rule_handler
    - Exception → generic_exception_handler (catch-all)

  - Add docstring with IDK tags:
    - IDK: initialization, exception-handler-registration
    - Responsibility: Register all exception handlers with FastAPI app
    - Usage: Call once in main.py after app = FastAPI()
    - Example code showing main.py integration

  - Add comment noting this should be called once at app startup

### Task 6: Add Jinja2 Template Variables
- Add header comment with Jinja2 variable:
  ```python
  # Generated by {{ config.project.name }} - Exception handling system
  # This template provides typed exceptions with FastAPI handler registration
  ```

- Add conditional comment for framework check (optional, for documentation):
  ```python
  {% if config.project.framework == "fastapi" %}
  # FastAPI project detected - handlers will be registered automatically
  {% endif %}
  ```

- Keep template minimal - don't add unnecessary Jinja2 logic unless needed

### Task 7: Create Rendered Reference Implementation
- Create directory `src/shared/infrastructure/` if not exists
- Read `config.yml` to extract values:
  - project.name = "tac-bootstrap"
  - project.framework = "none"
- Render the template with these values:
  - Replace `{{ config.project.name }}` → "tac-bootstrap"
  - Evaluate any `{% if %}` conditionals
- Create `src/shared/infrastructure/exceptions.py`:
  - Add header comments:
    ```python
    # Reference implementation - generated from exceptions.py.j2 template
    # This file serves as documentation for the exceptions.py template output
    # Not used by the CLI itself (tac-bootstrap has framework="none")
    ```
  - Include full rendered template content below header

### Task 8: Verify Dual Creation Pattern
- Verify both files exist:
  - Template: `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`
  - Rendered: `src/shared/infrastructure/exceptions.py`
- Compare structure consistency:
  - Same exception classes in both files
  - Same handler functions
  - Same register_exception_handlers() function
  - Template has Jinja2 syntax, rendered has actual values
- Read both files to confirm they're properly formatted

### Task 9: Validation Commands
- Execute all validation commands to ensure zero regressions:
  - Run tests: `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short`
  - Run linting: `cd tac_bootstrap_cli && uv run ruff check .`
  - Run type checking: `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/`
  - Smoke test CLI: `cd tac_bootstrap_cli && uv run tac-bootstrap --help`
- Verify all commands pass without errors
- If any failures occur, fix issues before proceeding

## Testing Strategy

### Unit Tests

**Template File Tests** (if template rendering logic exists):
- Test that exceptions.py.j2 is valid Jinja2 syntax
- Test rendering with sample config values
- Verify output contains all exception classes
- Verify register_exception_handlers() function exists

**Exception Class Tests** (for future integration):
When exceptions.py is integrated into actual FastAPI project:
- Test APIException base class instantiation
- Test each domain exception class:
  - Instantiate with required parameters
  - Verify message formatting
  - Verify details dict structure
  - Verify inheritance from APIException

**Handler Function Tests** (for future integration):
When used in FastAPI project:
- Mock FastAPI Request object
- Instantiate each exception with test data
- Call corresponding handler function
- Assert status code matches expected value
- Assert response JSON matches `{"error": {"type": "...", "message": "...", "details": {...}}}` format
- Test generic_exception_handler with unexpected Exception

**Integration Tests** (for future integration):
When used in FastAPI project:
- Create FastAPI test client with registered handlers
- Simulate raising each exception in a test endpoint
- Assert HTTP response status code
- Assert response JSON structure
- Test that unhandled exceptions return 500

### Edge Cases

**Exception Message Formatting:**
- EntityNotFoundError with special characters in entity_id
- DuplicateEntityError with None or empty values
- DomainValidationError with empty details dict
- Generic Exception with no message

**Handler Registration:**
- Calling register_exception_handlers() multiple times (should be idempotent)
- Registering with invalid app object
- Order of handler registration (generic Exception handler should be last)

**Error Response Format:**
- Details dict with None values
- Details dict with nested objects
- Long error messages (truncation or full message?)
- Unicode characters in error messages

**Security Edge Cases:**
- Generic Exception handler doesn't leak stack traces
- UnauthorizedError doesn't leak token details
- ForbiddenError doesn't leak permission implementation
- Details dict doesn't contain sensitive data accidentally

**Template Rendering Edge Cases:**
- Config values with special characters
- Missing config values (use defaults)
- Conditional rendering with framework="none" vs framework="fastapi"

## Acceptance Criteria

1. **Template File Exists:**
   - File created at `tac_bootstrap_cli/tac_bootstrap/templates/shared/exceptions.py.j2`
   - Valid Jinja2 syntax (no syntax errors)
   - Contains module-level docstring with IDK tags
   - Includes Responsibility, Invariants, Usage Examples sections

2. **Rendered File Exists:**
   - File created at `src/shared/infrastructure/exceptions.py`
   - Header comments indicate reference implementation
   - All Jinja2 variables replaced with config.yml values
   - FastAPI imports present (as reference, even though framework="none")

3. **Exception Classes Implemented:**
   - APIException base class with message and details attributes
   - 6 domain exceptions: EntityNotFoundError, DuplicateEntityError, DomainValidationError, UnauthorizedError, ForbiddenError, BusinessRuleError
   - Each exception has proper __init__ with typed parameters
   - Each exception constructs proper message and details dict
   - Each exception has docstring explaining purpose and HTTP status mapping

4. **HTTP Status Code Mapping:**
   - EntityNotFoundError → 404 (documented)
   - DuplicateEntityError → 409 (documented)
   - DomainValidationError → 422 (documented)
   - UnauthorizedError → 401 (documented)
   - ForbiddenError → 403 (documented)
   - BusinessRuleError → 400 (documented)
   - Generic Exception → 500 (documented)

5. **Exception Handlers Implemented:**
   - Handler function for each domain exception
   - Generic exception handler for unexpected errors
   - Each handler returns JSONResponse with consistent format
   - Error format: `{"error": {"type": "ExceptionName", "message": "...", "details": {...}}}`
   - Generic handler sanitizes messages (no stack trace leakage)

6. **register_exception_handlers() Function:**
   - Function signature: `register_exception_handlers(app: FastAPI) -> None`
   - Registers all 7 handlers (6 domain + 1 generic)
   - Uses `app.add_exception_handler(ExceptionClass, handler_function)`
   - Includes docstring with usage example showing main.py integration
   - Generic Exception handler registered last (catch-all)

7. **Documentation Quality:**
   - Module docstring follows IDK format from existing templates
   - Each exception class has docstring explaining use case
   - Each handler has docstring explaining status code
   - Usage examples show how to raise exceptions in service layer
   - Usage examples show how to register in main.py
   - Comments explain security decisions (sanitized generic errors)

8. **Dual Creation Consistency:**
   - Template and rendered files have same structure
   - Only difference is Jinja2 variables vs actual values
   - Both files are properly formatted and readable
   - Both files have proper imports (FastAPI, Request, JSONResponse)

9. **No Name Conflicts:**
   - ValidationError renamed to DomainValidationError (avoids Pydantic conflict)
   - No conflicts with Python builtin exceptions
   - Clear naming convention: *Error suffix for exceptions

10. **Validation Commands Pass:**
    - `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` → 0 failures
    - `cd tac_bootstrap_cli && uv run ruff check .` → no linting errors
    - `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` → no type errors
    - `cd tac_bootstrap_cli && uv run tac-bootstrap --help` → displays help without errors

## Validation Commands

Ejecutar todos los comandos para validar con cero regresiones:

- `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` - Tests unitarios
- `cd tac_bootstrap_cli && uv run ruff check .` - Linting
- `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` - Type check
- `cd tac_bootstrap_cli && uv run tac-bootstrap --help` - Smoke test

## Notes

**Design Decisions:**

1. **Why DomainValidationError instead of ValidationError?**
   - Avoids conflict with Pydantic's ValidationError (commonly imported in FastAPI projects)
   - Makes it explicit this is domain-level validation, not schema validation
   - Pydantic handles schema validation automatically; this is for business rules

2. **Why APIException base class?**
   - Enables catch-all handling if needed (catch APIException to handle all domain errors)
   - Makes exception hierarchy clear
   - Allows isinstance(exc, APIException) checks
   - Follows standard exception hierarchy patterns

3. **Why separate handler for each exception?**
   - Clear mapping of exception → status code → response format
   - Easy to customize individual error responses if needed
   - Explicit over implicit (no magic status code inference)
   - Easier to understand and maintain

4. **Why generic Exception handler?**
   - Security: prevents leaking stack traces or implementation details
   - Catch-all for unexpected errors (programmer errors, library exceptions, etc.)
   - Returns safe 500 response with sanitized message
   - Production safety net

5. **Why details: dict | None?**
   - Flexibility: some errors need structured details, others don't
   - Security: can omit details for sensitive errors (UnauthorizedError)
   - Frontend parsing: structured details enable better error UI
   - Backward compatible: None is valid, empty dict is valid

6. **Why not logging in handlers?**
   - Logging should be handled by middleware or centralized error handling
   - Keeps handlers focused on response formatting
   - Separation of concerns: handlers format, middleware logs
   - Can add logging later without changing handler signatures

**Future Enhancements (not in this task):**

- Add request_id to error responses for tracing
- Add timestamp to error responses
- Add path (request.url.path) to error responses
- Add internationalization support for error messages
- Add error codes (e.g., "ENTITY_NOT_FOUND", "DUPLICATE_ENTITY") for programmatic handling
- Add correlation IDs for distributed tracing
- Add structured logging in handlers
- Add custom exception for rate limiting (429)
- Add custom exception for service unavailable (503)

**Integration Points:**

- **BaseService**: Will replace HTTPException(404) with EntityNotFoundError
- **Repository**: Will raise DuplicateEntityError on unique constraint violations
- **Routes**: Will remove try/except blocks, let handlers catch exceptions
- **main.py**: Will call register_exception_handlers(app) at startup
- **Dependencies**: Can raise UnauthorizedError/ForbiddenError for auth failures

**Related Files to Update Later:**

- `templates/shared/base_service.py.j2`: Replace HTTPException with domain exceptions
- `templates/capabilities/crud_basic/routes.py.j2`: Remove try/except blocks
- `templates/capabilities/crud_basic/service.py.j2`: Use domain exceptions
- Main.py template (if exists): Add register_exception_handlers(app) call

**Testing Strategy for Generated Projects:**

When TAC Bootstrap generates a project with exceptions.py, integration tests should:
1. Create test FastAPI app with registered handlers
2. Create test endpoint that raises each exception type
3. Use TestClient to call endpoint and assert:
   - Status code matches expected value
   - Response JSON matches format
   - Error type matches exception class name
4. Test generic Exception handler with unexpected error
5. Test that frontend can parse error responses consistently

**Security Considerations:**

- Generic exception handler MUST NOT leak stack traces in production
- UnauthorizedError and ForbiddenError should not leak auth implementation details
- Details dict should not contain sensitive data (passwords, tokens, PII)
- Error messages should be user-friendly but not reveal internal structure
- Consider rate limiting on authentication errors (not in this task)

**Performance Considerations:**

- Exception handlers should be fast (simple dict construction + JSON serialization)
- No database calls or external API calls in handlers
- No heavy computation in handlers
- Register handlers once at startup, not per request

**Documentation Reminders:**

- Add usage examples to module docstring showing real-world scenarios
- Document which exceptions should be raised where (service layer vs routes)
- Document that Pydantic ValidationError is handled by FastAPI automatically
- Document that DomainValidationError is for business logic validation
- Add examples showing difference between 400, 401, 403, 422 status codes
