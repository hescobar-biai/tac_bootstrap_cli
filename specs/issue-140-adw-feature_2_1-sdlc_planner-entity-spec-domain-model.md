# Feature: EntitySpec Domain Model for Entity Generation

## Metadata
issue_number: `140`
adw_id: `feature_2_1`
issue_json: `{"number":140,"title":"Tarea 2.1: Modelo EntitySpec en domain","body":"/feature\n/adw_sdlc_iso\n/adw_id: feature_2_1\n\n\n**Tipo**: feature\n**Ganancia**: Modelo tipado que describe una entidad a generar: nombre, campos, tipos, relaciones. Sirve como contrato entre CLI, wizard y generador.\n\n**Instrucciones para el agente**:\n\n1. Crear `tac_bootstrap_cli/tac_bootstrap/domain/entity_config.py`\n2. Definir modelos Pydantic:\n   ```python\n   class FieldType(str, Enum):\n       STRING = \"str\"\n       INTEGER = \"int\"\n       FLOAT = \"float\"\n       BOOLEAN = \"bool\"\n       DATETIME = \"datetime\"\n       UUID = \"uuid\"\n       TEXT = \"text\"\n       DECIMAL = \"decimal\"\n       JSON = \"json\"\n\n   class FieldSpec(BaseModel):\n       name: str  # nombre del campo (snake_case)\n       field_type: FieldType\n       required: bool = True\n       unique: bool = False\n       indexed: bool = False\n       default: Any = None\n       description: str = \"\"\n       max_length: int | None = None  # para strings\n\n   class EntitySpec(BaseModel):\n       name: str  # PascalCase (e.g., \"Product\")\n       capability: str  # kebab-case (e.g., \"catalog\")\n       fields: list[FieldSpec]\n       authorized: bool = False  # generar con auth templates\n       async_mode: bool = False  # usar async repository\n       with_events: bool = False  # generar domain events\n\n       @property\n       def snake_name(self) -> str:\n           \"\"\"product\"\"\"\n       @property\n       def plural_name(self) -> str:\n           \"\"\"products\"\"\"\n       @property\n       def table_name(self) -> str:\n           \"\"\"products\"\"\"\n   ```\n3. Agregar validadores:\n   - `name` debe ser PascalCase\n   - `capability` debe ser kebab-case\n   - `fields` no puede estar vacio\n   - No se permiten campos con nombre `id`, `state`, `version`, `created_at`, `updated_at` (ya estan en BaseEntity)\n\n**Criterios de aceptacion**:\n- Validadores rechazan nombres invalidos con mensajes claros\n- Properties generan nombres derivados correctamente\n- Modelo es serializable a JSON/YAML\n\n# FASE 2: Comando `generate entity`\n\n**Objetivo**: Agregar un nuevo comando CLI que genera entidades CRUD completas siguiendo la vertical slice architecture.\n\n**Ganancia de la fase**: Los desarrolladores pueden crear entidades completas (domain, schemas, service, repo, routes) con un solo comando, eliminando el trabajo manual de copiar y adaptar boilerplate.\n"}`

## Feature Description

This feature introduces domain models that describe entities to be generated by TAC Bootstrap CLI. The `EntitySpec` model serves as a typed contract between the CLI, wizard interface, and code generation system, enabling the CLI to generate complete CRUD entities (domain models, schemas, services, repositories, routes) following vertical slice architecture.

The model provides comprehensive validation for entity definitions including naming conventions, field specifications, and reserved keyword protection. It also generates derived names (snake_case, plural, table names) from the entity name to ensure consistency across generated code layers.

## User Story

As a developer using TAC Bootstrap CLI
I want to define entities with typed field specifications
So that I can generate complete CRUD layers with a single command following best practices and architectural patterns

## Problem Statement

When generating entities for a project, developers need to define:
- Entity names following PascalCase convention
- Field specifications with types, constraints, and metadata
- Capability grouping using kebab-case convention
- Options for authentication, async operations, and domain events

Currently, there's no typed model to represent these specifications, leading to:
- Inconsistent entity definitions across generation workflows
- Manual validation of naming conventions
- Risk of using reserved field names that conflict with base entity classes
- No standardized way to derive related names (plurals, table names, etc.)

A domain model with comprehensive validation will ensure entity specifications are correct before code generation begins, preventing errors and ensuring consistency.

## Solution Statement

Create a `tac_bootstrap/domain/entity_config.py` module with three core Pydantic models:

1. **FieldType Enum**: Defines supported field types (string, integer, float, boolean, datetime, uuid, text, decimal, json)

2. **FieldSpec Model**: Represents individual entity fields with:
   - Validated field names (snake_case, no reserved words)
   - Type specification from FieldType enum
   - Constraint flags (required, unique, indexed)
   - Optional defaults and descriptions
   - Type-specific parameters (max_length for strings)

3. **EntitySpec Model**: Represents complete entity specifications with:
   - PascalCase entity name validation (min 2 chars, no leading numbers)
   - Kebab-case capability validation
   - Field list validation (non-empty, no reserved names)
   - Reserved field name protection (id, state, version, created_at, updated_at)
   - Python keyword validation
   - SQLAlchemy conflict validation (query, metadata, registry, mapper)
   - Derived name properties (snake_name, plural_name, table_name)
   - Optional flags for authentication, async mode, and domain events

All models use Pydantic v2 validators with clear error messages and support JSON/YAML serialization for configuration files.

## Relevant Files

### Existing Files to Reference

- `tac_bootstrap_cli/tac_bootstrap/domain/models.py` - Reference for existing Pydantic model patterns, field validators, and enum definitions
- `tac_bootstrap_cli/tac_bootstrap/domain/__init__.py` - Update exports to include new entity models
- `tac_bootstrap_cli/tests/test_models.py` - Reference for existing domain model test patterns
- `specs/issue-5-adw-e80a5f17-sdlc_planner-create-pydantic-config-models.md` - Reference for Pydantic model structure and validation patterns used in TACConfig

### New Files to Create

- `tac_bootstrap_cli/tac_bootstrap/domain/entity_config.py` - New domain models for entity specifications (main deliverable)
- `tac_bootstrap_cli/tests/test_entity_config.py` - Comprehensive unit tests for entity models

## Implementation Plan

### Phase 1: Foundation

**Objective**: Set up the entity_config module structure and basic type definitions

- Create `tac_bootstrap/domain/entity_config.py` with module docstring
- Import required dependencies (Enum, BaseModel, field_validator, keyword, re)
- Define FieldType enum with all supported database field types
- Add module-level constants for reserved field names and SQLAlchemy conflicts

### Phase 2: Core Implementation

**Objective**: Implement FieldSpec and EntitySpec models with full validation

- Implement FieldSpec model with all field attributes and validators
- Add field name validation (snake_case, Python keywords, SQLAlchemy conflicts)
- Implement EntitySpec model with entity-level attributes
- Add PascalCase validation for entity name (regex `^[A-Z][a-zA-Z0-9]*$`, min 2 chars)
- Add kebab-case validation for capability (regex `^[a-z][a-z0-9]*(-[a-z0-9]+)*$`)
- Add reserved field name validation (reject id, state, version, created_at, updated_at)
- Implement property methods for derived names (snake_name, plural_name, table_name)
- Add pluralization logic (append 's' with special handling for s/x/z/ch/sh endings)

### Phase 3: Integration

**Objective**: Integrate entity models with existing domain layer and prepare for CLI usage

- Update `tac_bootstrap/domain/__init__.py` to export new models
- Ensure models are JSON/YAML serializable with Pydantic v2 model_dump
- Verify compatibility with existing TACConfig model patterns
- Document model usage with comprehensive docstrings and examples

## Step by Step Tasks

### Task 1: Create entity_config.py module structure
- Create `tac_bootstrap_cli/tac_bootstrap/domain/entity_config.py`
- Add comprehensive module docstring explaining purpose and usage
- Import required dependencies:
  - `from enum import Enum`
  - `from typing import Any`
  - `from pydantic import BaseModel, field_validator`
  - `import keyword` (for Python keyword validation)
  - `import re` (for regex pattern validation)
- Define module-level constants:
  - `RESERVED_FIELD_NAMES` tuple with id, state, version, created_at, updated_at
  - `SQLALCHEMY_CONFLICTS` tuple with query, metadata, registry, mapper
  - `PASCALCASE_PATTERN` regex for entity names
  - `KEBABCASE_PATTERN` regex for capabilities
  - `SNAKECASE_PATTERN` regex for field names

### Task 2: Implement FieldType enum
- Define `FieldType(str, Enum)` class
- Add enum values: STRING, INTEGER, FLOAT, BOOLEAN, DATETIME, UUID, TEXT, DECIMAL, JSON
- Add class docstring explaining each type and when to use it

### Task 3: Implement FieldSpec model
- Define `FieldSpec(BaseModel)` class with fields:
  - `name: str` - Field name (snake_case)
  - `field_type: FieldType` - Type from enum
  - `required: bool = True` - Nullability
  - `unique: bool = False` - Uniqueness constraint
  - `indexed: bool = False` - Database index
  - `default: Any = None` - Default value (no type validation)
  - `description: str = ""` - Field documentation
  - `max_length: int | None = None` - For STRING/TEXT types
- Add comprehensive class docstring with attribute descriptions
- Add field validator for `name`:
  - Validate snake_case pattern with regex
  - Reject Python reserved keywords using `keyword.iskeyword()`
  - Reject SQLAlchemy conflict names from SQLALCHEMY_CONFLICTS
  - Provide clear error messages for each validation failure

### Task 4: Implement EntitySpec model - Basic Structure
- Define `EntitySpec(BaseModel)` class with fields:
  - `name: str` - Entity name (PascalCase)
  - `capability: str` - Capability grouping (kebab-case)
  - `fields: list[FieldSpec]` - Field specifications
  - `authorized: bool = False` - Generate with auth templates
  - `async_mode: bool = False` - Use async repository pattern
  - `with_events: bool = False` - Generate domain events
- Add comprehensive class docstring with examples

### Task 5: Implement EntitySpec validators
- Add `name` field validator:
  - Validate PascalCase pattern: `^[A-Z][a-zA-Z0-9]*$`
  - Ensure minimum 2 characters
  - Provide clear error message on failure
- Add `capability` field validator:
  - Validate kebab-case pattern: `^[a-z][a-z0-9]*(-[a-z0-9]+)*$`
  - Provide clear error message on failure
- Add `fields` field validator:
  - Ensure list is not empty
  - Check no field names in RESERVED_FIELD_NAMES
  - Provide clear error messages listing reserved names if found

### Task 6: Implement EntitySpec derived name properties
- Add `snake_name` property:
  - Convert PascalCase to snake_case using regex substitution
  - Example: "ProductCategory" -> "product_category"
  - Add docstring with example
- Add `plural_name` property:
  - Implement pluralization logic:
    - If name ends in 's', 'x', 'z', 'ch', 'sh': append 'es'
    - Otherwise: append 's'
  - Convert to snake_case
  - Example: "Product" -> "products", "Category" -> "categories"
  - Add docstring with examples
- Add `table_name` property:
  - Return plural_name (lowercase plural)
  - Example: "Product" -> "products"
  - Add docstring with example

### Task 7: Update domain package exports
- Edit `tac_bootstrap_cli/tac_bootstrap/domain/__init__.py`
- Add imports for new models:
  - `from tac_bootstrap.domain.entity_config import FieldType, FieldSpec, EntitySpec`
- Add to `__all__` list for public exports

### Task 8: Create comprehensive unit tests
- Create `tac_bootstrap_cli/tests/test_entity_config.py`
- Test FieldType enum values and serialization
- Test FieldSpec validation:
  - Valid snake_case field names
  - Reject Python keywords (class, def, return, etc.)
  - Reject SQLAlchemy conflicts (query, metadata, etc.)
  - Reject invalid patterns (PascalCase, kebab-case)
- Test EntitySpec validation:
  - Valid PascalCase names (Product, OAuth2Client)
  - Reject single-character names
  - Reject names starting with numbers
  - Reject lowercase names
  - Valid kebab-case capabilities (catalog, user-management)
  - Reject invalid capability patterns
  - Reject empty field lists
  - Reject reserved field names (id, state, version, created_at, updated_at)
- Test EntitySpec properties:
  - snake_name conversion (Product -> product, ProductCategory -> product_category)
  - plural_name generation (Product -> products, Category -> categories, Box -> boxes)
  - table_name generation (Product -> products)
- Test JSON/YAML serialization:
  - model_dump() produces valid dict
  - model_dump_json() produces valid JSON string
  - Round-trip serialization/deserialization

### Task 9: Validation - Run all validation commands
- Run unit tests: `cd tac_bootstrap_cli && uv run pytest tests/test_entity_config.py -v --tb=short`
- Run all tests: `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short`
- Run linting: `cd tac_bootstrap_cli && uv run ruff check .`
- Run type checking: `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/domain/entity_config.py`
- Verify no regressions in existing tests
- Fix any issues found before marking complete

## Testing Strategy

### Unit Tests

**FieldType Enum Tests**:
- Test all enum values are defined correctly
- Test string serialization works
- Test enum can be used in Pydantic models

**FieldSpec Validation Tests**:
- Valid field names: `user_name`, `email_address`, `is_active`, `created_at2`
- Invalid snake_case: `userName`, `user-name`, `User_Name`, `1_field`
- Python keywords: `class`, `def`, `return`, `import`, `for`, `while`, `try`
- SQLAlchemy conflicts: `query`, `metadata`, `registry`, `mapper`
- Field attributes: required, unique, indexed, default, description, max_length
- Type validation: all FieldType enum values work correctly

**EntitySpec Validation Tests**:
- Valid PascalCase names: `Product`, `UserProfile`, `OAuth2Client`, `Product2`
- Invalid names: `product` (lowercase), `A` (single char), `2Product` (starts with number), `product_name` (snake_case)
- Minimum length: reject names with less than 2 characters
- Valid capabilities: `catalog`, `user-management`, `api-gateway`
- Invalid capabilities: `Catalog`, `user_management`, `api.gateway`, `123abc`
- Empty field list: must have at least one field
- Reserved field names: reject fields named `id`, `state`, `version`, `created_at`, `updated_at`
- Multiple validations can fail at once with clear error messages

**Property Tests**:
- `snake_name`:
  - `Product` -> `product`
  - `UserProfile` -> `user_profile`
  - `OAuth2Client` -> `o_auth2_client`
  - `APIKey` -> `api_key`
- `plural_name`:
  - `Product` -> `products`
  - `Category` -> `categories`
  - `Box` -> `boxes`
  - `Quiz` -> `quizzes`
  - `Batch` -> `batches`
  - `Bush` -> `bushes`
- `table_name`:
  - Same as plural_name (lowercase plural)

**Serialization Tests**:
- Create EntitySpec instance with all fields
- Serialize to dict with model_dump()
- Serialize to JSON with model_dump_json()
- Deserialize from dict and verify equality
- Verify nested FieldSpec models serialize correctly

### Edge Cases

1. **Single-character entity names**: Must be rejected (e.g., "A", "X")
2. **Entity names starting with numbers**: Must be rejected (e.g., "2Product", "3DModel")
3. **All-uppercase acronyms**: Should work (e.g., "API", "HTTP") - valid PascalCase
4. **Numbers in entity names**: Should work (e.g., "OAuth2Client", "Product2") - valid PascalCase
5. **Empty field list**: Must be rejected with clear error message
6. **Field with reserved name**: Must be rejected with list of reserved names
7. **Multiple reserved fields**: Error should list all conflicts
8. **Field with Python keyword**: Must be rejected (e.g., field named "class")
9. **Capability with uppercase**: Must be rejected (e.g., "UserManagement")
10. **Capability with underscores**: Must be rejected (e.g., "user_management")
11. **Pluralization edge cases**:
    - Words ending in 's': "Status" -> "statuses"
    - Words ending in 'x': "Index" -> "indexes"
    - Words ending in 'z': "Quiz" -> "quizzes"
    - Words ending in 'ch': "Branch" -> "branches"
    - Words ending in 'sh': "Wish" -> "wishes"
    - Words ending in 'y': "Category" -> "categorys" (simple rule, not "categories")
12. **max_length on non-STRING fields**: Should be allowed but ignored at domain level
13. **default value type mismatch**: Should be allowed (validated at database layer)

## Acceptance Criteria

- [ ] `entity_config.py` module created with comprehensive docstrings
- [ ] `FieldType` enum defines all 9 field types (STRING, INTEGER, FLOAT, BOOLEAN, DATETIME, UUID, TEXT, DECIMAL, JSON)
- [ ] `FieldSpec` model validates field names:
  - [ ] Accepts valid snake_case names
  - [ ] Rejects Python reserved keywords with clear error message
  - [ ] Rejects SQLAlchemy conflicts (query, metadata, registry, mapper) with clear error message
  - [ ] Rejects invalid naming patterns (PascalCase, kebab-case, leading numbers)
- [ ] `EntitySpec` model validates entity specifications:
  - [ ] Accepts valid PascalCase names (min 2 chars, allows internal numbers)
  - [ ] Rejects invalid names with clear error messages
  - [ ] Accepts valid kebab-case capabilities
  - [ ] Rejects invalid capabilities with clear error message
  - [ ] Rejects empty field lists with clear error message
  - [ ] Rejects reserved field names (id, state, version, created_at, updated_at) with clear error message listing conflicts
- [ ] `EntitySpec` properties generate correct derived names:
  - [ ] `snake_name` converts PascalCase to snake_case correctly
  - [ ] `plural_name` generates correct plurals (append 's' or 'es' based on ending)
  - [ ] `table_name` returns lowercase plural
- [ ] Domain package exports updated in `__init__.py`
- [ ] Comprehensive unit tests cover:
  - [ ] All validation rules with positive and negative cases
  - [ ] All property derivations with edge cases
  - [ ] JSON/YAML serialization round-trips
  - [ ] Clear error messages for all validation failures
- [ ] All validation commands pass:
  - [ ] Unit tests: `pytest tests/test_entity_config.py -v`
  - [ ] All tests: `pytest tests/ -v`
  - [ ] Linting: `ruff check .`
  - [ ] Type checking: `mypy tac_bootstrap/domain/entity_config.py`
- [ ] No regressions in existing tests
- [ ] Models are fully serializable to JSON/YAML for configuration files

## Validation Commands

Run all commands to validate implementation with zero regressions:

```bash
# Unit tests for entity_config
cd tac_bootstrap_cli && uv run pytest tests/test_entity_config.py -v --tb=short

# All unit tests (verify no regressions)
cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short

# Linting
cd tac_bootstrap_cli && uv run ruff check .

# Type checking
cd tac_bootstrap_cli && uv run mypy tac_bootstrap/domain/entity_config.py

# Smoke test CLI
cd tac_bootstrap_cli && uv run tac-bootstrap --help
```

## Notes

### Design Decisions (from Auto-Resolved Clarifications)

1. **Pluralization**: Simple rule-based approach (append 's' or 'es'). Edge cases like "Person" -> "People" are rare in domain modeling and can be handled via future custom configuration if needed.

2. **max_length**: Optional field, defaults to None. Database layer will handle VARCHAR(255) vs TEXT decisions based on database dialect.

3. **Python Keywords**: Validated using `keyword.iskeyword()` from standard library to prevent runtime errors when fields become object attributes.

4. **Default Value Validation**: No type checking at Pydantic level. Complex validation (datetime strings vs objects, JSON serialization) is deferred to database/ORM layer.

5. **SQLAlchemy Conflicts**: Small curated list of common conflicts (query, metadata, registry, mapper) prevents hard-to-debug issues. List can be expanded based on real-world feedback.

6. **PascalCase Pattern**: `^[A-Z][a-zA-Z0-9]*$` with minimum 2 characters. Supports realistic entity names like "OAuth2Client" and "Product2".

7. **Capability Validation**: Format validation only (`^[a-z][a-z0-9]*(-[a-z0-9]+)*$`). Project-level validation (checking against existing capabilities) belongs in application/CLI layer, not domain.

8. **Table Names**: Simple lowercase plural, no database-specific prefixes or length constraints. Infrastructure layer can handle dialect-specific requirements if needed.

9. **Optional Fields**: Allow entities with all optional fields - valid use case for configuration objects and user preferences. BaseEntity provides required fields (id, etc.).

### Future Enhancements

- Custom pluralization rules for irregular nouns
- Relationship field types (ForeignKey, ManyToMany)
- Field-level validation rules (regex patterns, min/max values)
- Database dialect-specific type mappings
- Custom table name overrides
- Composite unique constraints
- Index definitions (single and composite)

### Dependencies

- Pydantic >= 2.5.0 (already in pyproject.toml)
- Python >= 3.10 (for type union syntax `int | None`)
