# Feature: Bottom-Up Fractal Documentation Generator Template

## Metadata
issue_number: `170`
adw_id: `feature_6_2`
issue_json: `{"number":170,"title":"Tarea 6.2: Template gen_docs_fractal.py","body":"feature\n/adw_sdlc_zte_iso\n/adw_id: feature_6_2\n\n**Tipo**: feature\n**Ganancia**: Proyectos generados incluyen un generador de documentacion en arbol (un .md por carpeta) que da vision completa de la arquitectura.\n\n**Instrucciones para el agente**:\n\n1. Crear template: `tac_bootstrap_cli/tac_bootstrap/templates/scripts/gen_docs_fractal.py.j2`\n2. Crear renderizado en raiz: `scripts/gen_docs_fractal.py` (con permisos de ejecucion)\n3. Tomar como base `ai_docs/doc/create-crud-entity/generating-fractal-docs/scripts/gen_docs_fractal.py`\n3. Adaptarlo con variables Jinja2:\n   - `{{ config.paths.app_root | default(\"src\") }}` → `--include-root` default\n   - `{{ config.project.name }}` → domain en frontmatter\n   - `{{ config.project.language }}` → determina que archivos leer (*.py, *.ts, etc.)\n4. El script generado debe:\n   - Leer docstrings de Python y JSDoc de TypeScript\n   - Generar un markdown por carpeta en `docs/`\n   - Nombre del markdown: path concatenado (e.g., `docs/src/catalog/domain.md`)\n   - Procesamiento bottom-up (carpetas mas profundas primero)\n   - Frontmatter con: doc_type, domain, owner, level, tags, idk, related_code, children\n   - Secciones requeridas: Overview, Responsibilities, Key APIs, Invariants, Side Effects, Operational Notes\n   - Modo `complement` que preserva body existente y solo actualiza frontmatter\n   - Carga vocabulario IDK canonico desde `canonical_idk.yml` si existe\n5. Dependencias:\n   ```python\n   # /// script\n   # dependencies = [\"openai\", \"python-dotenv\", \"pyyaml\"]\n   # ///\n   ```\n\n**Criterios de aceptacion**:\n- Template renderiza sin errores\n- Script genera docs/ con estructura correcta\n- Bottom-up: procesa hojas antes que padres\n- Respeta modo complement (no borra body existente)\n- Frontmatter YAML es valido\nFASE 6: Documentacion Fractal como Skill\n\n**Objetivo**: Incluir los generadores de documentacion fractal como parte de los proyectos generados, con slash command para invocacion facil.\n\n**Ganancia de la fase**: Proyectos generados incluyen herramientas de documentacion automatica que mantienen docs sincronizados con el codigo, usando LLM local o remoto.\n\n---\n"}`

## Feature Description
This feature creates a Jinja2 template for a bottom-up fractal documentation generator that will be included in all projects generated by TAC Bootstrap. The script generates one markdown file per directory under `docs/`, processing from the deepest directories upward, creating a comprehensive architectural view of the codebase.

The generated script reads Python docstrings and TypeScript JSDoc comments to build folder-level documentation with structured frontmatter and required sections. It preserves existing documentation in "complement" mode (default), ensuring user edits are never lost. The script supports configurable LLM providers (OpenAI by default) and optionally loads canonical IDK vocabulary from a YAML file.

## User Story
As a developer using TAC Bootstrap-generated projects
I want an automated fractal documentation generator included in my project
So that I can maintain up-to-date architectural documentation that reflects my folder structure, preserving my manual edits while auto-updating structural metadata

## Problem Statement
Architectural documentation quickly becomes stale and disconnected from the actual codebase structure. Manual maintenance of folder-level documentation is:
- Time-consuming and tedious
- Difficult to keep synchronized with code changes
- Often incomplete or outdated
- Lacks structural metadata about relationships and hierarchy
- Prone to inconsistencies across folders

Projects need an automated way to generate and maintain comprehensive, folder-level documentation that:
- Reflects the actual directory structure
- Preserves user-written content
- Maintains structural metadata automatically
- Provides bottom-up architectural views
- Uses LLM to generate meaningful content from code

## Solution Statement
Create a Jinja2 template (`gen_docs_fractal.py.j2`) based on the existing reference implementation in `ai_docs/doc/create-crud-entity/generating-fractal-docs/scripts/gen_docs_fractal.py`. The template will:

1. **Generate one markdown per folder** with path-concatenated names (e.g., `docs/src/catalog/domain.md`)
2. **Process bottom-up** (deepest directories first) so parent docs can reference children
3. **Use complement mode by default** to preserve existing documentation body and only update frontmatter
4. **Auto-populate structural metadata** (children, level) while leaving semantic metadata (owner, related_code) empty for manual curation
5. **Support Python and TypeScript explicitly** with graceful degradation for other languages
6. **Read docstrings/JSDoc** to extract code-level documentation
7. **Generate structured frontmatter** with doc_type, domain, owner, level, tags, idk, related_code, children
8. **Require OPENAI_API_KEY** and fail fast with clear error if missing
9. **Optionally load canonical IDK vocabulary** from `canonical_idk.yml` if present (no error if missing)
10. **Preserve unrecognized files** in docs/ to prevent data loss
11. **Generate required sections** (Overview, Responsibilities, Key APIs, Invariants, Side Effects, Operational Notes)

The template will be rendered into the generated project's `scripts/` directory with executable permissions.

## Relevant Files

### Existing Reference Implementation
- `ai_docs/doc/create-crud-entity/generating-fractal-docs/scripts/gen_docs_fractal.py` - Base script to adapt as template (789 lines, full implementation with bottom-up traversal, frontmatter parsing, complement mode)

### TAC Bootstrap Infrastructure
- `tac_bootstrap_cli/tac_bootstrap/domain/models.py` - TACConfig, ProjectSpec, PathsSpec Pydantic models
- `tac_bootstrap_cli/tac_bootstrap/application/scaffold_service.py` - Service that applies scaffold plans
- `tac_bootstrap_cli/tac_bootstrap/infrastructure/template_repo.py` - Jinja2 rendering service
- `config.yml` - Source of configuration values (project.language, project.name, paths.app_root)

### Example Template References
- `tac_bootstrap_cli/tac_bootstrap/templates/scripts/gen_docstring_jsdocs.py.j2` - Similar script template with PEP 723 dependencies and Jinja2 variables
- `tac_bootstrap_cli/tac_bootstrap/templates/adws/adw_sdlc_iso.py.j2` - Example Python template with inline dependencies

### New Files
- `tac_bootstrap_cli/tac_bootstrap/templates/scripts/gen_docs_fractal.py.j2` - New Jinja2 template
- `scripts/gen_docs_fractal.py` - Rendered output in project root (for validation)

### Testing
- `tac_bootstrap_cli/tests/test_scaffold_service.py` - Verify template is included in scaffolding
- Manual testing with `uv run scripts/gen_docs_fractal.py`

## Implementation Plan

### Phase 1: Template Creation
Create the Jinja2 template structure with proper inline script dependencies and Jinja2 variable placeholders.

1. Copy base script from `ai_docs/doc/create-crud-entity/generating-fractal-docs/scripts/gen_docs_fractal.py`
2. Add PEP 723 inline script dependencies header
3. Insert Jinja2 variables for project configuration
4. Create template file at `tac_bootstrap_cli/tac_bootstrap/templates/scripts/gen_docs_fractal.py.j2`

### Phase 2: Configuration & API Integration
Adapt the script for configurable LLM providers with fail-fast validation.

1. Update API configuration to use OpenAI by default
2. Add environment variable support (OPENAI_API_KEY, OPENAI_MODEL)
3. Implement fail-fast validation if OPENAI_API_KEY is missing
4. Add optional config.llm.provider and config.llm.model support
5. Default model to 'gpt-4o-mini' if not specified

### Phase 3: Multi-Language Support
Implement explicit Python/TypeScript support with graceful degradation.

1. Detect project language from `{{ config.project.language }}`
2. Set file extensions based on language (*.py for Python, *.ts/*.tsx for TypeScript)
3. For unsupported languages: skip file content reading, generate structure-based docs, log warning
4. Handle files without docstrings by including 'No documentation available' placeholder

### Phase 4: Integration with TAC Bootstrap
Integrate the template into ScaffoldService and validate rendering.

1. Add template to the list of rendered scripts in scaffold_service.py
2. Ensure rendered script has executable permissions
3. Test rendering with various config.yml configurations
4. Validate frontmatter YAML is valid
5. Verify bottom-up processing order

## Step by Step Tasks

### Task 1: Create Base Template Structure
- Create `tac_bootstrap_cli/tac_bootstrap/templates/scripts/gen_docs_fractal.py.j2`
- Copy content from `ai_docs/doc/create-crud-entity/generating-fractal-docs/scripts/gen_docs_fractal.py`
- Add PEP 723 inline script dependencies header:
  ```python
  #!/usr/bin/env python3
  # /// script
  # dependencies = ["openai", "python-dotenv", "pyyaml"]
  # ///
  ```
- Update module docstring to reference `{{ config.project.name }}`
- Add template comments explaining Jinja2 variables

### Task 2: Insert Jinja2 Configuration Variables
- Replace hardcoded defaults with Jinja2 variables:
  - `--include-root` default: `{{ config.paths.app_root | default("src") }}`
  - Domain in frontmatter: derive from path but use `{{ config.project.name }}` in prompts
  - Owner field default: `{{ config.project.owner if config.project.owner else '' }}`
- Add language-based file extension logic using `{% if config.project.language == "python" %}`
- Configure default extensions:
  - Python: `[".py"]`
  - TypeScript: `[".ts", ".tsx"]`
  - JavaScript: `[".js", ".jsx"]`
  - Other: `[".py", ".ts", ".tsx", ".js", ".jsx"]` (all supported)

### Task 3: Update API Configuration for OpenAI
- Remove hardcoded Ollama defaults, use OpenAI defaults instead
- Update default base_url to `https://api.openai.com/v1`
- Update default model to `gpt-4o-mini`
- Add environment variable support:
  ```python
  from dotenv import load_dotenv
  load_dotenv()

  api_key = os.getenv("OPENAI_API_KEY")
  if not api_key:
      print("ERROR: OPENAI_API_KEY environment variable is required.", file=sys.stderr)
      print("Set it in your .env file or export it before running this script.", file=sys.stderr)
      return 1

  base_url = os.getenv("OPENAI_BASE_URL", "https://api.openai.com/v1")
  model = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
  ```
- Update argparse defaults to use environment variables

### Task 4: Add CLI Arguments
- Add `--include-root` argument (default from Jinja2 config)
- Add `--output-dir` argument (default: 'docs/')
- Add `--mode` argument choices: ['generate', 'complement'], default 'complement'
- Add `--model` argument to override LLM model
- Add `--dry-run` flag
- Update argparse help text with clear descriptions

### Task 5: Implement Graceful Language Handling
- Add warning logging for unsupported languages:
  ```python
  if language not in ['python', 'typescript', 'javascript']:
      print(f"WARNING: Language '{language}' not explicitly supported. Generating structure-based docs only.", file=sys.stderr)
  ```
- For unsupported languages: skip docstring/JSDoc extraction, still generate docs from directory structure
- Handle missing docstrings: include file in listing with 'No documentation available'

### Task 6: Update canonical_idk.yml Loading
- Make canonical_idk.yml loading optional and silent:
  ```python
  canonical_idk_path = repo / "canonical_idk.yml"
  canonical_idk_by_domain = {}
  if canonical_idk_path.exists():
      try:
          canonical_idk_by_domain = load_canonical_idk_from_yaml(canonical_idk_path)
      except Exception as e:
          # Silent failure - IDK vocabulary is optional
          pass
  ```
- Remove any error/warning messages for missing canonical_idk.yml
- Leave IDK fields empty if vocabulary not available

### Task 7: Auto-Populate Structural Metadata
- Implement auto-population of 'children' field from subdirectory docs
- Implement auto-calculation of 'level' field from directory depth
- Leave 'owner' field empty by default (or use config.project.owner if available)
- Leave 'related_code' field empty for manual curation

### Task 8: Preserve Existing Files in docs/
- Update file writing logic to only touch files matching generated naming pattern (path-concatenated)
- Preserve all other files in docs/
- Log info message about which files were skipped/preserved:
  ```python
  print(f"INFO: Preserving existing file (not matching generated pattern): {filename}")
  ```

### Task 9: Integrate Template into ScaffoldService
- Add `gen_docs_fractal.py` to the list of scripts rendered in `scaffold_service.py`
- Verify template is included in `_add_scripts()` method
- Ensure file is created with executable permissions (0o755)
- Test with `tac-bootstrap init` and verify script is generated

### Task 10: Validation & Testing
Execute validation commands to ensure zero regressions:
- Run unit tests: `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short`
- Run linting: `cd tac_bootstrap_cli && uv run ruff check .`
- Run type checking: `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/`
- Run smoke test: `cd tac_bootstrap_cli && uv run tac-bootstrap --help`
- Manual test: Render template with test config and verify output
- Functional test: Run generated script with `uv run scripts/gen_docs_fractal.py --dry-run`

## Testing Strategy

### Unit Tests
- Test template renders without errors with basic config
- Test Jinja2 variable substitution (project.name, paths.app_root, project.language)
- Test language-based file extension selection
- Verify executable permissions are set on rendered script

### Integration Tests
- Test with Python project config (language: python)
- Test with TypeScript project config (language: typescript)
- Test with unsupported language (verify graceful degradation)
- Test complement mode preserves existing body
- Test bottom-up processing order

### Manual Tests
- Run generated script with --dry-run and verify output
- Run with real codebase and verify docs/ structure
- Verify frontmatter YAML is valid
- Test with missing OPENAI_API_KEY (should fail fast)
- Test with missing canonical_idk.yml (should proceed silently)

### Edge Cases
- Empty directories (no code files)
- Directories with only non-Python/TS files
- Files without docstrings
- Invalid YAML in existing docs
- Missing parent directories in docs/
- Read-only docs/ directory

## Acceptance Criteria
1. Template renders without errors using Jinja2
2. Generated script has PEP 723 dependencies header with openai, python-dotenv, pyyaml
3. Script uses `{{ config.paths.app_root | default("src") }}` for --include-root default
4. Script uses `{{ config.project.name }}` in LLM prompts for domain context
5. Script uses `{{ config.project.language }}` to determine default file extensions
6. Script generates one .md per folder in docs/ with path-concatenated names
7. Processing is bottom-up (deepest directories first)
8. Complement mode (default) preserves existing body, only updates frontmatter
9. Frontmatter includes: doc_type, domain, owner, level, tags, idk, related_code, children
10. Required sections are generated: Overview, Responsibilities, Key APIs, Invariants, Side Effects, Operational Notes
11. Script requires OPENAI_API_KEY and fails fast if missing with helpful error message
12. Script loads canonical_idk.yml if present, proceeds silently if missing
13. Script preserves existing files in docs/ that don't match generated naming pattern
14. Script supports Python (*.py) and TypeScript (*.ts, *.tsx) explicitly
15. Script logs warning for unsupported languages but continues with structure-based docs
16. Script is executable (permissions 0o755)
17. Frontmatter YAML is valid and parseable
18. All validation commands pass with zero regressions

## Validation Commands
Execute all commands to validate with zero regressions:

- `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` - Tests unitarios
- `cd tac_bootstrap_cli && uv run ruff check .` - Linting
- `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` - Type check
- `cd tac_bootstrap_cli && uv run tac-bootstrap --help` - Smoke test
- Manual: `cd tac_bootstrap_cli && uv run tac-bootstrap init test-project --language python --framework none --architecture ddd` - Generate test project
- Manual: `cd test-project && uv run scripts/gen_docs_fractal.py --dry-run` - Test generated script

## Notes

### Auto-Resolved Clarifications Summary
- **Unsupported languages**: Gracefully degrade to structure-based docs with warning
- **Missing canonical_idk.yml**: Proceed silently without error
- **LLM provider**: Use OpenAI by default (OPENAI_API_KEY required)
- **Files without docstrings**: Include with 'No documentation available' placeholder
- **Owner field default**: Empty string (optionally use config.project.owner)
- **CLI arguments**: --include-root, --output-dir, --mode, --model, --dry-run
- **Related code field**: Leave empty (future enhancement for import analysis)
- **Level field**: Directory depth from configured root
- **API key requirement**: Fail fast with clear error if missing
- **Existing files preservation**: Preserve all files not matching generated naming pattern

### Future Enhancements
- Support for more languages (Go, Rust, Java)
- Import analysis for auto-populating related_code field
- Interactive mode for confirming overwrites
- Parallel processing for large codebases
- Support for local LLM providers (Ollama)
- Metrics and progress reporting

### Dependencies
This feature depends on:
- Feature 6.1 (gen_docstring_jsdocs.py template) for pattern reference
- PEP 723 inline script dependencies support
- OpenAI Python SDK compatibility
- YAML frontmatter parsing
