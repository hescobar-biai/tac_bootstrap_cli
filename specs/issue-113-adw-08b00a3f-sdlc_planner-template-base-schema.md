# Feature: Template base_schema.py - Pydantic DTOs for API Layer

## Metadata
issue_number: `113`
adw_id: `08b00a3f`
issue_json: `{"number":113,"title":"Tarea 1.2: Template base_schema.py","body":"/feature\n**Ganancia**: DTOs estandarizados (Create/Update/Response) que separan la capa API del dominio. Cada entidad nueva solo necesita heredar y agregar sus campos especificos.\n\n**Instrucciones para el agente**:\n\n1. Crear template: `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_schema.py.j2`\n2. Crear renderizado en raiz: `src/shared/domain/base_schema.py`\n2. Definir 3 clases base Pydantic:\n   - `BaseCreate`: campos comunes para creacion (ninguno por default, las entidades agregan los suyos)\n   - `BaseUpdate`: todos los campos opcionales para partial updates\n   - `BaseResponse`: campos de respuesta (id, state, version, created_at, updated_at, created_by, updated_by)\n3. Configuracion `model_config = ConfigDict(from_attributes=True)` en BaseResponse\n4. Agregar ejemplo en docstring de como heredar:\n   ```python\n   class ProductCreate(BaseCreate):\n       name: str\n       price: float\n   ```\n\n**Criterios de aceptacion**:\n- BaseResponse puede instanciarse desde un ORM model (from_attributes=True)\n- BaseUpdate tiene todos campos como Optional\n- Renderiza sin errores\n- Documentacion complementarai leeala:/ ai_docs/doc/create-crud-entity"}`

## Feature Description

Create standardized Pydantic schema base classes (DTOs) for API-layer data transfer objects that separate API concerns from domain entity models. These base schemas provide the foundation for Create, Update, and Response patterns for all CRUD operations in generated projects.

The template serves dual purpose:
1. **Jinja2 template** for projects generated by TAC Bootstrap CLI
2. **Rendered implementation** for use within tac_bootstrap itself (dogfooding pattern)

The feature eliminates 30+ lines of boilerplate per entity by providing reusable base classes that inherit and extend rather than copy-paste.

## User Story

As a **developer using TAC Bootstrap to generate a project**
I want to **have standardized base schema classes for DTOs**
So that **I can quickly create API request/response schemas with consistent patterns and minimal boilerplate**

## Problem Statement

When building CRUD APIs, developers repeatedly write similar Pydantic schemas for each entity:
- **CreateSchema**: Captures user input for resource creation
- **UpdateSchema**: Captures partial updates with all optional fields
- **ResponseSchema**: Returns resource data with metadata (id, timestamps, audit trail)

Without base classes, each entity requires duplicating:
- `model_config = ConfigDict(from_attributes=True)` for ORM compatibility
- Common fields (id, state, version, timestamps, audit fields)
- The pattern of making all Update fields Optional

This leads to:
- Inconsistent API contracts across entities
- Copy-paste errors when adding new entities
- Maintenance burden when updating common fields
- Lack of clear separation between domain models and API DTOs

## Solution Statement

Create three base Pydantic schema classes that establish standardized patterns:

1. **BaseCreate**: Empty base class for creation DTOs
   - Entities inherit and add their specific required fields
   - No common fields by default (creation data is entity-specific)

2. **BaseUpdate**: Independent base class for partial updates
   - Entities inherit and add their fields as Optional
   - Supports partial updates where clients send only changed fields

3. **BaseResponse**: Common response fields for all entities
   - `id: UUID` - Unique identifier matching domain Entity
   - `state: str` - Simple string state (entities can override with enums)
   - `version: int` - Version for optimistic locking
   - `created_at: datetime` - UTC creation timestamp
   - `updated_at: datetime` - UTC last update timestamp
   - `created_by: UUID` - User ID who created the resource
   - `updated_by: UUID` - User ID who last updated the resource
   - `model_config = ConfigDict(from_attributes=True)` - Enables ORM model conversion

The approach follows separation of concerns:
- **Domain entities** (base_entity.py): Business logic, validation, lifecycle
- **API schemas** (base_schema.py): Request/response DTOs, API contracts
- **Service layer**: Maps between schemas and entities, injects audit data

## Relevant Files

### Existing Files
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_entity.py.j2`: Template for domain entities (reference for field patterns, issue #111)
- `src/shared/domain/base_entity.py`: Rendered domain entity (shows Entity model with audit trail)
- `app_docs/feature-a1a5289c-base-entity-template.md`: Documentation for base entity implementation

### New Files
- `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_schema.py.j2`: Jinja2 template for base schemas (MAIN DELIVERABLE)
- `src/shared/domain/base_schema.py`: Rendered schema file for tac_bootstrap's own use (dogfooding)

## Implementation Plan

### Phase 1: Foundation
1. Study existing base_entity.py template to understand field patterns
2. Review auto-resolved clarifications to understand design decisions
3. Create directory structure if needed: `src/shared/domain/`

### Phase 2: Core Implementation
1. Create `base_schema.py.j2` template in `tac_bootstrap_cli/tac_bootstrap/templates/shared/`
2. Define BaseCreate, BaseUpdate, BaseResponse classes with Pydantic
3. Add comprehensive IDK docstrings following base_entity.py pattern
4. Include usage examples in module docstring
5. Ensure all necessary imports are included (UUID, datetime, Pydantic)

### Phase 3: Integration
1. Render template to `src/shared/domain/base_schema.py` for tac_bootstrap's use
2. Validate imports work correctly
3. Verify template renders without Jinja2 errors

## Step by Step Tasks

### Task 1: Create Jinja2 Template
- Create file: `tac_bootstrap_cli/tac_bootstrap/templates/shared/base_schema.py.j2`
- Add module-level docstring with IDK pattern explaining responsibilities
- Import required dependencies: `from pydantic import BaseModel, ConfigDict, Field`
- Import UUID and datetime: `from uuid import UUID` and `from datetime import datetime`

### Task 2: Implement BaseCreate Class
- Define empty Pydantic BaseModel class named `BaseCreate`
- Add comprehensive IDK docstring explaining:
  - Responsibility: Foundation for entity creation DTOs
  - Invariants: No common fields (entity-specific)
  - Usage: Entities inherit and add required fields
- Include inheritance example in docstring:
  ```python
  class ProductCreate(BaseCreate):
      name: str
      price: float
  ```

### Task 3: Implement BaseUpdate Class
- Define Pydantic BaseModel class named `BaseUpdate`
- Keep independent from BaseCreate (no inheritance)
- Add comprehensive IDK docstring explaining:
  - Responsibility: Foundation for partial update DTOs
  - Invariants: All fields should be Optional in subclasses
  - Pattern: Supports PATCH operations with partial data
- Include usage example showing all fields as Optional

### Task 4: Implement BaseResponse Class
- Define Pydantic BaseModel class named `BaseResponse`
- Add `model_config = ConfigDict(from_attributes=True)` for ORM compatibility
- Define response fields with proper types:
  - `id: UUID` - Unique identifier
  - `state: str` - Entity state as string
  - `version: int` - Version number
  - `created_at: datetime` - UTC creation timestamp
  - `updated_at: datetime` - UTC modification timestamp
  - `created_by: UUID` - Creator user ID
  - `updated_by: UUID` - Last modifier user ID
- Use Field() with description for each field
- Add comprehensive IDK docstring
- Include usage example showing entity response inheritance

### Task 5: Render Template to src/shared/domain/
- Create directory `src/shared/domain/` if it doesn't exist
- Render `base_schema.py.j2` to `src/shared/domain/base_schema.py`
- Verify template rendering produces valid Python
- Test import: `python -c "from src.shared.domain.base_schema import BaseCreate, BaseUpdate, BaseResponse; print('Import successful')"`

### Task 6: Validation and Testing
- Verify BaseResponse can instantiate from dict with from_attributes
- Verify BaseUpdate pattern supports partial updates
- Confirm no Jinja2 template errors during rendering
- Run validation commands (tests, linting, type checking)

## Testing Strategy

### Unit Tests
No unit tests required at this phase. Template is validated through:
1. Successful rendering without Jinja2 errors
2. Successful Python import of rendered file
3. Manual inspection of generated code

### Edge Cases
- **No template variables**: Template is static (no Jinja2 vars), renders identically to source
- **from_attributes compatibility**: BaseResponse must support instantiation from ORM models
- **Optional fields in Update**: Pattern allows partial updates
- **UUID types**: Ensure compatibility between domain Entity (str UUID) and schema (UUID type)

## Acceptance Criteria

- [ ] Template file `base_schema.py.j2` created in correct location
- [ ] Rendered file `base_schema.py` exists in `src/shared/domain/`
- [ ] BaseCreate class defined with empty body and inheritance example
- [ ] BaseUpdate class defined independently (no inheritance from BaseCreate)
- [ ] BaseResponse class defined with 7 fields: id, state, version, created_at, updated_at, created_by, updated_by
- [ ] BaseResponse has `model_config = ConfigDict(from_attributes=True)`
- [ ] All classes include comprehensive IDK docstrings
- [ ] All necessary imports included (UUID, datetime, Pydantic)
- [ ] Template renders without Jinja2 errors
- [ ] Rendered file imports successfully in Python
- [ ] All fields use correct types: UUID for ids, datetime for timestamps, str for state, int for version
- [ ] No audit fields (created_by, updated_by) in BaseCreate or BaseUpdate

## Validation Commands

Ejecutar todos los comandos para validar con cero regresiones:

- `python -c "from src.shared.domain.base_schema import BaseCreate, BaseUpdate, BaseResponse; print('Import successful')"` - Validate imports
- `cd tac_bootstrap_cli && uv run pytest tests/ -v --tb=short` - Tests unitarios
- `cd tac_bootstrap_cli && uv run ruff check .` - Linting
- `cd tac_bootstrap_cli && uv run mypy tac_bootstrap/` - Type check
- `cd tac_bootstrap_cli && uv run tac-bootstrap --help` - Smoke test

## Notes

### Design Decisions (from Auto-Resolved Clarifications)

**Audit Fields Separation**
- Audit fields (created_by, updated_by) are NOT in BaseCreate/BaseUpdate
- Rationale: Audit fields are system-managed, not user-provided
- Service layer should inject these automatically based on authenticated user context
- Including them in Create/Update would allow users to manipulate audit data (security concern)

**BaseUpdate Independence**
- BaseUpdate does NOT inherit from BaseCreate
- Rationale: Different purposes - Create has required fields, Update has all optional
- Inheritance would complicate making all fields optional
- Keeps classes decoupled and simpler

**Field Types**
- `id`: UUID (matches base_entity.py, better distributed system support)
- `state`: str (flexible, entities can override with specific enums)
- `version`: int (standard optimistic locking pattern)
- `created_at/updated_at`: datetime (proper serialization, Pydantic handles JSON)
- `created_by/updated_by`: UUID (matches base_entity.py pattern)

**Template Variables**
- No Jinja2 template variables needed
- Base schema classes are pure Python type definitions
- Universal across all generated projects (project-agnostic)

**from_attributes Configuration**
- BaseResponse needs `model_config = ConfigDict(from_attributes=True)`
- Enables instantiation from ORM models: `ProductResponse.model_validate(product_entity)`
- Critical for service layer mapping: Entity â†’ Response DTO

### Related Documentation
- Issue #111: base_entity.py template (domain layer counterpart)
- `app_docs/feature-a1a5289c-base-entity-template.md`: Entity implementation reference
- `ai_docs/doc/create-crud-entity/`: Full CRUD entity documentation

### Future Enhancements
- Add Jinja2 variables for optional field customization
- Generate example schemas for common entities (User, Product)
- Add validation rules base classes
- Support for nested schemas and relationships
- Pagination response wrappers
