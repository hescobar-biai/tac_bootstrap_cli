# Plan: Implementar `tac upgrade` - Sistema de Actualización de Agentic Layer

## Resumen

Implementar un comando `tac upgrade` que permita a usuarios actualizar sus proyectos generados con versiones anteriores de TAC Bootstrap a la última versión, preservando sus configuraciones personalizadas.

---

## Arquitectura de la Solución

```
┌─────────────────────────────────────────────────────────────────┐
│                     tac upgrade flow                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Leer config.yml existente                                   │
│     └─> Extraer versión actual (si no existe → default "0.1.0")│
│     └─> Extraer configuración del usuario                       │
│                                                                 │
│  2. Comparar versiones                                          │
│     └─> CLI version > Project version? → Upgrade disponible    │
│     └─> Mostrar changelog de cambios                           │
│                                                                 │
│  3. Backup (opcional)                                           │
│     └─> Copiar adws/, .claude/ a .tac-backup-{timestamp}/      │
│                                                                 │
│  4. Regenerar archivos                                          │
│     └─> Usar config existente + templates nuevos               │
│     └─> Actualizar solo: adws/, .claude/, scripts/             │
│     └─> NO tocar: src/, código del usuario                     │
│                                                                 │
│  5. Actualizar version en config.yml                            │
│     └─> version: "0.1.0" → version: "0.2.0"                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Tareas de Implementación

### TAREA 1: Agregar campo `version` al schema y templates

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/domain/models.py`

**Descripción**: Agregar campo `version` al modelo `TACConfig` para trackear la versión de TAC Bootstrap usada para generar el proyecto.

**Cambios**:

```python
# En TACConfig, agregar campo version
class TACConfig(BaseModel):
    """Root configuration model for TAC Bootstrap."""

    version: str = Field(
        default="0.2.0",
        description="TAC Bootstrap version used to generate this project"
    )
    project: ProjectSpec
    paths: PathsSpec = Field(default_factory=PathsSpec)
    commands: CommandsSpec = Field(default_factory=CommandsSpec)
    agentic: AgenticSpec = Field(default_factory=AgenticSpec)
    claude: ClaudeConfig = Field(default_factory=ClaudeConfig)
```

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/templates/config/config.yml.j2`

**Cambios**:

```yaml
# TAC Bootstrap Configuration
# Generated by TAC Bootstrap v{{ config.version }}

version: "{{ config.version }}"

project:
  name: "{{ config.project.name }}"
  # ... resto del template
```

**Nota Importante**: Los proyectos generados actualmente (v0.1.0) NO tienen campo `version` en su `config.yml`. El `UpgradeService` debe detectar esto y asumir `"0.1.0"` como versión default.

**Criterios de Aceptación**:
- [ ] Campo `version` existe en `TACConfig` con default "0.2.0"
- [ ] Template `config.yml.j2` incluye campo version
- [ ] Tests existentes pasan
- [ ] Nuevo test verifica que version se genera correctamente
- [ ] Proyectos sin campo version se asumen como v0.1.0

---

### TAREA 2: Crear constante de versión centralizada

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/__init__.py`

**Descripción**: Crear constante `__version__` centralizada que se use en todo el proyecto.

**Cambios**:

```python
"""TAC Bootstrap - Agentic Layer Generator."""

__version__ = "0.2.0"
__all__ = ["__version__"]
```

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/domain/models.py`

**Cambios**:

```python
from tac_bootstrap import __version__

class TACConfig(BaseModel):
    version: str = Field(default=__version__, ...)
```

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/interfaces/cli.py`

**Cambios**:

```python
from tac_bootstrap import __version__

@app.callback()
def main(
    version: bool = typer.Option(None, "--version", "-v", callback=version_callback)
):
    """TAC Bootstrap - Agentic Layer Generator."""
    pass

def version_callback(value: bool):
    if value:
        print(f"TAC Bootstrap v{__version__}")
        raise typer.Exit()
```

**Criterios de Aceptación**:
- [ ] `__version__` definida en `__init__.py`
- [ ] CLI muestra versión con `tac --version`
- [ ] `TACConfig.version` usa `__version__` como default
- [ ] Un solo lugar para actualizar versión

---

### TAREA 3: Crear servicio `UpgradeService`

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/application/upgrade_service.py`

**Descripción**: Servicio que maneja la lógica de actualización de proyectos.

**Código**:

```python
"""Upgrade service for TAC Bootstrap projects."""

from __future__ import annotations

import shutil
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple, List
from packaging import version as pkg_version

import yaml
from rich.console import Console

from tac_bootstrap import __version__
from tac_bootstrap.domain.models import TACConfig
from tac_bootstrap.application.scaffold_service import ScaffoldService

console = Console()


class UpgradeService:
    """Service for upgrading TAC Bootstrap projects to newer versions."""

    # Directorios que se actualizan (no código del usuario)
    UPGRADEABLE_DIRS = ["adws", ".claude", "scripts"]

    # Archivos que se actualizan en root
    UPGRADEABLE_FILES = ["config.yml"]

    def __init__(self, project_path: Path):
        """Initialize upgrade service.

        Args:
            project_path: Path to the project to upgrade
        """
        self.project_path = project_path
        self.config_path = project_path / "config.yml"
        self.scaffold_service = ScaffoldService()

    def get_current_version(self) -> Optional[str]:
        """Get current project version from config.yml.

        Returns:
            Version string or None if not found/invalid
        """
        if not self.config_path.exists():
            return None

        try:
            with open(self.config_path) as f:
                config_data = yaml.safe_load(f)
                return config_data.get("version", "0.1.0")  # Default for old projects
        except Exception:
            return None

    def get_target_version(self) -> str:
        """Get target version (current CLI version)."""
        return __version__

    def needs_upgrade(self) -> Tuple[bool, str, str]:
        """Check if project needs upgrade.

        Returns:
            Tuple of (needs_upgrade, current_version, target_version)
        """
        current = self.get_current_version()
        target = self.get_target_version()

        if current is None:
            return False, "unknown", target

        try:
            needs = pkg_version.parse(current) < pkg_version.parse(target)
            return needs, current, target
        except Exception:
            return False, current, target

    def load_existing_config(self) -> Optional[TACConfig]:
        """Load existing project configuration.

        Returns:
            TACConfig or None if invalid
        """
        if not self.config_path.exists():
            return None

        try:
            with open(self.config_path) as f:
                config_data = yaml.safe_load(f)

            # Actualizar version al target
            config_data["version"] = self.get_target_version()

            return TACConfig(**config_data)
        except Exception as e:
            console.print(f"[red]Error loading config: {e}[/red]")
            return None

    def create_backup(self) -> Path:
        """Create backup of upgradeable directories.

        Returns:
            Path to backup directory
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = self.project_path / f".tac-backup-{timestamp}"
        backup_dir.mkdir(exist_ok=True)

        for dir_name in self.UPGRADEABLE_DIRS:
            source = self.project_path / dir_name
            if source.exists():
                shutil.copytree(source, backup_dir / dir_name)

        # Backup config.yml
        if self.config_path.exists():
            shutil.copy2(self.config_path, backup_dir / "config.yml")

        return backup_dir

    def get_changes_preview(self) -> List[str]:
        """Get list of changes that will be made.

        Returns:
            List of change descriptions
        """
        changes = []

        for dir_name in self.UPGRADEABLE_DIRS:
            dir_path = self.project_path / dir_name
            if dir_path.exists():
                changes.append(f"Update {dir_name}/ directory")
            else:
                changes.append(f"Create {dir_name}/ directory")

        changes.append("Update version in config.yml")

        return changes

    def perform_upgrade(self, backup: bool = True) -> Tuple[bool, str]:
        """Perform the upgrade.

        Args:
            backup: Whether to create backup before upgrading

        Returns:
            Tuple of (success, message)
        """
        # Load existing config
        config = self.load_existing_config()
        if config is None:
            return False, "Could not load existing configuration"

        # Create backup if requested
        backup_path = None
        if backup:
            backup_path = self.create_backup()
            console.print(f"[green]Created backup at: {backup_path}[/green]")

        try:
            # Remove old directories
            for dir_name in self.UPGRADEABLE_DIRS:
                dir_path = self.project_path / dir_name
                if dir_path.exists():
                    shutil.rmtree(dir_path)

            # Regenerate using scaffold service with updated config
            self.scaffold_service.scaffold_project(config, self.project_path)

            return True, f"Successfully upgraded to v{self.get_target_version()}"

        except Exception as e:
            # Restore from backup if available
            if backup_path and backup_path.exists():
                console.print("[yellow]Restoring from backup...[/yellow]")
                for dir_name in self.UPGRADEABLE_DIRS:
                    backup_source = backup_path / dir_name
                    if backup_source.exists():
                        target = self.project_path / dir_name
                        if target.exists():
                            shutil.rmtree(target)
                        shutil.copytree(backup_source, target)

            return False, f"Upgrade failed: {e}"
```

**Criterios de Aceptación**:
- [ ] `UpgradeService` creado con métodos documentados
- [ ] Detecta versión actual del proyecto
- [ ] Compara versiones correctamente
- [ ] Crea backups antes de actualizar
- [ ] Regenera solo directorios de agentic layer
- [ ] Preserva configuración del usuario
- [ ] Restaura backup si falla

---

### TAREA 4: Crear comando CLI `tac upgrade`

**Archivo**: `tac_bootstrap_cli/tac_bootstrap/interfaces/cli.py`

**Descripción**: Agregar comando `upgrade` al CLI de Typer.

**Código**:

```python
from tac_bootstrap.application.upgrade_service import UpgradeService

@app.command()
def upgrade(
    path: Path = typer.Argument(
        Path("."),
        help="Path to project to upgrade",
        exists=True,
        file_okay=False,
        dir_okay=True,
    ),
    dry_run: bool = typer.Option(
        False,
        "--dry-run",
        "-n",
        help="Show what would be changed without making changes",
    ),
    backup: bool = typer.Option(
        True,
        "--backup/--no-backup",
        help="Create backup before upgrading (default: enabled)",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Force upgrade even if versions match",
    ),
):
    """Upgrade agentic layer to latest TAC Bootstrap version.

    This command updates the adws/, .claude/, and scripts/ directories
    to the latest templates while preserving your project configuration.

    Examples:
        tac upgrade                    # Upgrade current directory
        tac upgrade ./my-project       # Upgrade specific project
        tac upgrade --dry-run          # Preview changes
        tac upgrade --no-backup        # Upgrade without backup
    """
    project_path = path.resolve()

    # Verify it's a TAC project
    config_file = project_path / "config.yml"
    if not config_file.exists():
        console.print("[red]Error: No config.yml found. Is this a TAC Bootstrap project?[/red]")
        raise typer.Exit(1)

    service = UpgradeService(project_path)

    # Check versions
    needs_upgrade, current_ver, target_ver = service.needs_upgrade()

    console.print(f"\n[bold]TAC Bootstrap Upgrade[/bold]")
    console.print(f"  Current version: [yellow]{current_ver}[/yellow]")
    console.print(f"  Target version:  [green]{target_ver}[/green]")

    if not needs_upgrade and not force:
        console.print("\n[green]Project is already up to date![/green]")
        raise typer.Exit(0)

    # Show changes preview
    console.print("\n[bold]Changes to be made:[/bold]")
    for change in service.get_changes_preview():
        console.print(f"  • {change}")

    if dry_run:
        console.print("\n[yellow]Dry run - no changes made[/yellow]")
        raise typer.Exit(0)

    # Confirm upgrade
    if not typer.confirm("\nProceed with upgrade?", default=True):
        console.print("[yellow]Upgrade cancelled[/yellow]")
        raise typer.Exit(0)

    # Perform upgrade
    console.print("\n[bold]Upgrading...[/bold]")
    success, message = service.perform_upgrade(backup=backup)

    if success:
        console.print(f"\n[green]✓ {message}[/green]")
        if backup:
            console.print("[dim]Backup preserved. Delete manually when confirmed working.[/dim]")
    else:
        console.print(f"\n[red]✗ {message}[/red]")
        raise typer.Exit(1)
```

**Criterios de Aceptación**:
- [ ] Comando `tac upgrade` disponible
- [ ] `--dry-run` muestra cambios sin aplicar
- [ ] `--no-backup` desactiva backup
- [ ] `--force` fuerza upgrade aunque versiones coincidan
- [ ] Muestra versión actual y target
- [ ] Pide confirmación antes de proceder
- [ ] Mensajes claros de éxito/error

---

### TAREA 5: Agregar dependencia `packaging`

**Archivo**: `tac_bootstrap_cli/pyproject.toml`

**Descripción**: Agregar dependencia `packaging` para comparación semántica de versiones.

**Cambios**:

```toml
[project]
dependencies = [
    "typer>=0.9.0",
    "rich>=13.0.0",
    "jinja2>=3.1.0",
    "pydantic>=2.0.0",
    "pyyaml>=6.0",
    "packaging>=23.0",  # Para comparación de versiones
]
```

**Criterios de Aceptación**:
- [ ] `packaging` agregado a dependencias
- [ ] `uv sync` instala correctamente
- [ ] Import funciona en upgrade_service.py

---

### TAREA 6: Crear tests para UpgradeService

**Archivo**: `tac_bootstrap_cli/tests/test_upgrade_service.py`

**Descripción**: Tests comprehensivos para el servicio de upgrade.

**Código**:

```python
"""Tests for upgrade service."""

import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock
import yaml
import shutil

from tac_bootstrap.application.upgrade_service import UpgradeService
from tac_bootstrap import __version__


@pytest.fixture
def mock_project(tmp_path):
    """Create a mock TAC project structure."""
    # Create config.yml with old version
    config = {
        "version": "0.1.0",
        "project": {
            "name": "test-project",
            "mode": "new",
            "language": "python",
            "framework": "fastapi",
            "architecture": "simple",
            "package_manager": "uv",
        },
        "paths": {"app_root": "src"},
        "commands": {
            "start": "uv run fastapi dev",
            "test": "uv run pytest",
        },
        "agentic": {
            "target_branch": "main",
            "worktrees": {"enabled": True},
        },
        "claude": {
            "settings": {"project_name": "test-project"},
        },
    }

    config_path = tmp_path / "config.yml"
    with open(config_path, "w") as f:
        yaml.dump(config, f)

    # Create directories
    (tmp_path / "adws").mkdir()
    (tmp_path / "adws" / "old_file.py").write_text("# old")
    (tmp_path / ".claude").mkdir()
    (tmp_path / "scripts").mkdir()
    (tmp_path / "src").mkdir()  # User code - should not be touched
    (tmp_path / "src" / "main.py").write_text("# user code")

    return tmp_path


class TestUpgradeService:
    """Tests for UpgradeService."""

    def test_get_current_version(self, mock_project):
        """Test reading current version from config."""
        service = UpgradeService(mock_project)
        assert service.get_current_version() == "0.1.0"

    def test_get_current_version_missing_file(self, tmp_path):
        """Test handling missing config.yml."""
        service = UpgradeService(tmp_path)
        assert service.get_current_version() is None

    def test_get_current_version_no_version_field(self, tmp_path):
        """Test handling config without version field (proyectos pre-0.2.0)."""
        # Simula un config.yml generado con v0.1.0 (sin campo version)
        config = {
            "project": {"name": "test", "language": "python"},
            "commands": {"start": "uv run"},
            # NO tiene campo "version" - así son todos los proyectos actuales
        }
        with open(tmp_path / "config.yml", "w") as f:
            yaml.dump(config, f)

        service = UpgradeService(tmp_path)
        # Debe asumir 0.1.0 para proyectos sin version
        assert service.get_current_version() == "0.1.0"

    def test_needs_upgrade_true(self, mock_project):
        """Test detecting when upgrade is needed."""
        service = UpgradeService(mock_project)
        needs, current, target = service.needs_upgrade()

        assert needs is True
        assert current == "0.1.0"
        assert target == __version__

    def test_needs_upgrade_false_same_version(self, mock_project):
        """Test when versions match."""
        # Update config to current version
        config_path = mock_project / "config.yml"
        with open(config_path) as f:
            config = yaml.safe_load(f)
        config["version"] = __version__
        with open(config_path, "w") as f:
            yaml.dump(config, f)

        service = UpgradeService(mock_project)
        needs, current, target = service.needs_upgrade()

        assert needs is False
        assert current == __version__

    def test_create_backup(self, mock_project):
        """Test backup creation."""
        service = UpgradeService(mock_project)
        backup_path = service.create_backup()

        assert backup_path.exists()
        assert (backup_path / "adws").exists()
        assert (backup_path / ".claude").exists()
        assert (backup_path / "scripts").exists()
        assert (backup_path / "config.yml").exists()
        # src should NOT be backed up (user code)
        assert not (backup_path / "src").exists()

    def test_get_changes_preview(self, mock_project):
        """Test changes preview."""
        service = UpgradeService(mock_project)
        changes = service.get_changes_preview()

        assert "Update adws/ directory" in changes
        assert "Update .claude/ directory" in changes
        assert "Update version in config.yml" in changes

    def test_load_existing_config(self, mock_project):
        """Test loading and updating config."""
        service = UpgradeService(mock_project)
        config = service.load_existing_config()

        assert config is not None
        assert config.version == __version__  # Updated to target
        assert config.project.name == "test-project"
        assert config.project.language.value == "python"

    def test_perform_upgrade_preserves_user_code(self, mock_project):
        """Test that upgrade preserves user code."""
        service = UpgradeService(mock_project)

        # Mock scaffold service to avoid actual file generation
        with patch.object(service.scaffold_service, 'scaffold_project'):
            success, message = service.perform_upgrade(backup=False)

        # User code should still exist
        assert (mock_project / "src" / "main.py").exists()
        assert (mock_project / "src" / "main.py").read_text() == "# user code"

    def test_perform_upgrade_with_backup(self, mock_project):
        """Test upgrade creates backup."""
        service = UpgradeService(mock_project)

        with patch.object(service.scaffold_service, 'scaffold_project'):
            success, message = service.perform_upgrade(backup=True)

        # Check backup was created
        backups = list(mock_project.glob(".tac-backup-*"))
        assert len(backups) == 1


class TestUpgradeServiceEdgeCases:
    """Edge case tests for UpgradeService."""

    def test_upgrade_invalid_config(self, tmp_path):
        """Test handling invalid config.yml."""
        (tmp_path / "config.yml").write_text("invalid: yaml: content: [")

        service = UpgradeService(tmp_path)
        config = service.load_existing_config()

        assert config is None

    def test_upgrade_missing_directories(self, tmp_path):
        """Test upgrade when some directories don't exist."""
        config = {
            "version": "0.1.0",
            "project": {"name": "test", "mode": "new", "language": "python",
                       "framework": "none", "architecture": "simple",
                       "package_manager": "uv"},
            "paths": {},
            "commands": {},
            "agentic": {"target_branch": "main", "worktrees": {"enabled": False}},
            "claude": {"settings": {"project_name": "test"}},
        }
        with open(tmp_path / "config.yml", "w") as f:
            yaml.dump(config, f)

        service = UpgradeService(tmp_path)
        changes = service.get_changes_preview()

        # Should indicate directories will be created
        assert "Create adws/ directory" in changes
```

**Criterios de Aceptación**:
- [ ] Tests cubren casos principales
- [ ] Tests cubren edge cases
- [ ] Tests de backup funcionan
- [ ] Tests de preservación de código usuario
- [ ] Todos los tests pasan

---

### TAREA 7: Crear tests para comando CLI upgrade

**Archivo**: `tac_bootstrap_cli/tests/test_cli_upgrade.py`

**Descripción**: Tests de integración para el comando CLI.

**Código**:

```python
"""Tests for CLI upgrade command."""

import pytest
from pathlib import Path
from typer.testing import CliRunner
from unittest.mock import patch, MagicMock
import yaml

from tac_bootstrap.interfaces.cli import app
from tac_bootstrap import __version__


runner = CliRunner()


@pytest.fixture
def mock_project(tmp_path):
    """Create mock project for CLI tests."""
    config = {
        "version": "0.1.0",
        "project": {"name": "test", "mode": "new", "language": "python",
                   "framework": "none", "architecture": "simple",
                   "package_manager": "uv"},
        "paths": {"app_root": "."},
        "commands": {"start": "", "test": ""},
        "agentic": {"target_branch": "main", "worktrees": {"enabled": False}},
        "claude": {"settings": {"project_name": "test"}},
    }
    with open(tmp_path / "config.yml", "w") as f:
        yaml.dump(config, f)

    (tmp_path / "adws").mkdir()
    (tmp_path / ".claude").mkdir()

    return tmp_path


class TestCliUpgrade:
    """Tests for tac upgrade command."""

    def test_upgrade_dry_run(self, mock_project):
        """Test --dry-run shows changes without applying."""
        result = runner.invoke(app, ["upgrade", str(mock_project), "--dry-run"])

        assert result.exit_code == 0
        assert "Dry run" in result.stdout
        assert "no changes made" in result.stdout

    def test_upgrade_no_config(self, tmp_path):
        """Test error when no config.yml exists."""
        result = runner.invoke(app, ["upgrade", str(tmp_path)])

        assert result.exit_code == 1
        assert "No config.yml found" in result.stdout

    def test_upgrade_already_current(self, mock_project):
        """Test when project is already up to date."""
        # Update to current version
        config_path = mock_project / "config.yml"
        with open(config_path) as f:
            config = yaml.safe_load(f)
        config["version"] = __version__
        with open(config_path, "w") as f:
            yaml.dump(config, f)

        result = runner.invoke(app, ["upgrade", str(mock_project)])

        assert result.exit_code == 0
        assert "already up to date" in result.stdout

    def test_upgrade_force(self, mock_project):
        """Test --force upgrades even when current."""
        # Update to current version
        config_path = mock_project / "config.yml"
        with open(config_path) as f:
            config = yaml.safe_load(f)
        config["version"] = __version__
        with open(config_path, "w") as f:
            yaml.dump(config, f)

        # Should show changes with --force
        result = runner.invoke(app, ["upgrade", str(mock_project), "--force", "--dry-run"])

        assert result.exit_code == 0
        assert "Changes to be made" in result.stdout

    def test_upgrade_shows_versions(self, mock_project):
        """Test that versions are displayed."""
        result = runner.invoke(app, ["upgrade", str(mock_project), "--dry-run"])

        assert "0.1.0" in result.stdout  # Current
        assert __version__ in result.stdout  # Target
```

**Criterios de Aceptación**:
- [ ] Test `--dry-run` funciona
- [ ] Test error sin config.yml
- [ ] Test proyecto actualizado
- [ ] Test `--force`
- [ ] Test muestra versiones

---

### TAREA 8: Documentar comando en README

**Archivo**: `tac_bootstrap_cli/README.md` y `README.md` principal

**Descripción**: Agregar documentación del comando upgrade.

**Contenido a agregar**:

```markdown
## Upgrading Projects

If you have a project created with an older version of TAC Bootstrap,
you can upgrade it to the latest templates:

```bash
# Check what would be upgraded
tac upgrade --dry-run

# Upgrade with backup (default)
tac upgrade

# Upgrade without backup
tac upgrade --no-backup

# Force upgrade even if versions match
tac upgrade --force

# Upgrade specific project
tac upgrade ./path/to/project
```

### What Gets Upgraded

The upgrade command updates:
- `adws/` - AI Developer Workflows
- `.claude/` - Claude Code configuration
- `scripts/` - Utility scripts

It preserves:
- `src/` - Your application code
- `config.yml` - Your configuration (only version is updated)
- Any custom files you've added

### Backup

By default, a backup is created at `.tac-backup-{timestamp}/` before upgrading.
Delete it manually after confirming the upgrade works correctly.
```

**Criterios de Aceptación**:
- [ ] Documentación clara del comando
- [ ] Ejemplos de uso
- [ ] Explicación de qué se actualiza
- [ ] Información sobre backups

---

### TAREA 9: Actualizar proyectos existentes (v0.1.0 → v0.2.0)

**Archivo**: `CHANGELOG.md` (crear si no existe)

**Descripción**: Documentar cambios entre versiones para usuarios.

**Contenido**:

```markdown
# Changelog

## [0.2.0] - 2025-XX-XX

### Added
- `tac upgrade` command for updating existing projects
- Version tracking in `config.yml`
- `target_branch` configuration in `config.yml`
- `--version` flag for CLI

### Changed
- All ADW templates synchronized with latest modules
- Improved worktree port management
- Enhanced agent retry logic with rate limiting

### Fixed
- Jinja2 template escaping for JSON examples
- Template synchronization issues

### Upgrade Notes
Projects created with v0.1.0 can upgrade using:
```bash
tac upgrade
```

This will update adws/, .claude/, and scripts/ while preserving your code.

## [0.1.0] - Initial Release

- Initial TAC Bootstrap CLI
- Project scaffolding for Python and TypeScript
- ADW workflow templates
- Claude Code integration
```

**Criterios de Aceptación**:
- [ ] CHANGELOG.md creado
- [ ] Cambios documentados
- [ ] Instrucciones de upgrade claras

---

## Orden de Implementación

```
TAREA 2 → TAREA 1 → TAREA 5 → TAREA 3 → TAREA 4 → TAREA 6 → TAREA 7 → TAREA 8 → TAREA 9
   │         │         │         │         │         │         │         │         │
   ▼         ▼         ▼         ▼         ▼         ▼         ▼         ▼         ▼
__version__ → Model  → deps  → Service → CLI    → Tests  → CLI    → Docs  → Change
             update          upgrade    command   unit     tests          log
```

## Verificación Final

```bash
# 1. Correr todos los tests
cd tac_bootstrap_cli && uv run pytest tests/ -v

# 2. Verificar CLI funciona
uv run tac --version
uv run tac upgrade --help

# 3. Test manual con proyecto real
mkdir /tmp/test-upgrade
cd /tmp/test-upgrade
# Crear config.yml con version: "0.1.0"
# Ejecutar: tac upgrade --dry-run

# 4. Release
gh release create v0.2.0 --repo celes-app/tac-cli-dist --title "v0.2.0" --notes-file CHANGELOG.md
```

---

## Estimación

| Tarea | Complejidad |
|-------|-------------|
| 1. Campo version | Baja |
| 2. Constante version | Baja |
| 3. UpgradeService | Media |
| 4. CLI command | Media |
| 5. Dependencia | Baja |
| 6. Tests service | Media |
| 7. Tests CLI | Media |
| 8. Documentación | Baja |
| 9. Changelog | Baja |

---

## Notas Adicionales

1. **Versionado Semántico**: Usar semver (MAJOR.MINOR.PATCH)
   - MAJOR: Cambios breaking
   - MINOR: Nuevas features (como upgrade)
   - PATCH: Bug fixes

2. **Compatibilidad**: El upgrade debe funcionar con proyectos sin campo `version`:
   - Si `config.yml` no tiene campo `version` → asumir `"0.1.0"`
   - Esto aplica a TODOS los proyectos generados antes de v0.2.0
   - El upgrade agregará el campo `version` automáticamente

3. **Rollback**: El backup permite rollback manual si algo falla

4. **Idempotencia**: Ejecutar upgrade múltiples veces debe ser seguro
