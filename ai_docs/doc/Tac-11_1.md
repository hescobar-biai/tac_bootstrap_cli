## Transcripción (00:15 — …): Custom Agents y Cloud Code SDK

**00:15**  
Agentic engineering leads every engineer down one single path: **better agents, more agents, and then custom agents**.  
If you can prompt engineer and context engineer a single agent successfully, then the next step is to add more agents—scale your compute to scale your impact.  
Then once you learn to delegate work to sub agents and new primary agents, there's only one place left to go: **custom agents**.

**00:45**  
But why isn't cloud code, codec cli, or the Gemini CLI enough?  
The out-of-the-box agents are incredible, but there's a massive problem with these tools: they're built for everyone's code base, not yours.  
This mismatch can cost you hundreds of hours and millions of tokens, scaling as your codebase grows.

**01:06**  
This lesson is about flipping that equation.  
Here we master custom agents so your compute works for your domain, your problems, your edge cases.  
This is where all the alpha is in engineering: it's in the hard specific problems that most engineers and most agents can't solve out of the box.  
You can't walk up to these problems and solve them without unique domain knowledge.  
And custom agents let you pass your domain-specific unique knowledge right to your agents.

**01:38**  
Custom agents let you do a few special things:

- You can take the core four—**context, model, prompt, and tools**—and scale them beyond the defaults.  
- You can solve domain-specific problems with targeted repeatable workflows.  
- Custom agents also let you protect your codebase, protect your assets, and protect other engineers from agents calling the wrong tools at the wrong time.

**02:08**  
Ultimately, custom agents let you take two tactics of agent coding to their limit:

- Template your engineering directly into your agent.  
- Push the **one agent, one prompt, one purpose** tactic to its limits.

**02:24**  
And sometimes it's not about building 100% custom agents at all.  
By knowing how to use programmatic agents like the Claude Code SDK, you can deploy out-of-the-box agents like Cloud Code programmatically and just make a few tweaks so that it performs better for your use case.  
You don't always have to reinvent the agent from zero.

**02:44**  
In this advanced lesson, we showcase eight unique custom agents built on the Claw Code SDK—each one showing you how to deploy across your stack, products, and engineering life cycle.  
The agents are on the horizon. It's time to master agents by going all the way to the bare metal—to the custom agent—so you can scale your compute far beyond the rest.

---

## Progressión por niveles

**03:05**  
As usual, we're going to start simple and progress through more capable agents step by step so you can understand how to build these from zero.

**03:22**  
In the building specialized agents codebase inside of `apps`, you can see eight custom agents.  
We're going to break down—some of these have multiple agents embedded within each.  
Let's start simple with the **Pong agent**.

---

## Pong Agent (sistema y ley del agente)

**03:31**  
Here is a simple agent that's going to showcase the most important aspect of custom agents.  
You can see we have a simple, concise user prompt and agent response. And we have some session stats.

**03:51**  
Let's run this again. Let's go ahead and change our prompt.  
"Hello." Simple prompt. We're just getting started with custom agents.  
I said hello. It just responded with **pong**.

**03:54**  
"Summarize this codebase." There's my user prompt.  
And once again, the Pong agent is responding again with **pong**.  
What's going on here?

**04:09**  
Let's ask it what's happening.  
"Can you do anything other than pong?"  
Okay, there's a user prompt.  
And okay, so all this agent does is **ponk** (pong).  
Type one more here. Just going to write "ping."

**04:19**  
This silly agent encapsulates the most important concept when you're building custom agents:  
No matter what we prompt here, the response is always **pong**.

**04:28**  
Why is that? Let's dive in to this file.

**04:33**  
So the first most important concept is none other than the **system prompt**.  
We are using the cloud code SDK and we're setting up only two things.  
We're modifying just two aspects of this agent—but it changes everything.

**04:48**  
You can see cloud for sonnet and here the system prompt.  
So let's open up the system prompt.  
You can see we have this dedicated `load_system_prompt` method.  
There's the path to the prompt. Let's open it.

**05:01**  
We have completely overwritten the Claw Code system prompt with this title of our agent purpose and we have a simple three-line instruction:

- You are a pong agent.  
- Always respond exactly with pong.  
- That's it.

**05:11**  
The system prompt is the most important element of your custom agents with zero exceptions.  
We are modifying the core four—specifically the prompt.  
But now we have two very important prompts to pay attention to: **system prompts and user prompts**.

**05:25**  
The system prompt affects every single user prompt the agent runs. Every single one.  
So all of your work is multiplied by your system prompt.

---

## Cómo funciona el Cloud Code SDK

**05:36**  
So how does the Cloud Code SDK work? Let's break down the key ideas.  
The SDK works like this:

1. You set up your options.  
2. You set up your agent.  
3. Here we're just running the query.  
4. And then you handle the response.

**05:49**  
The Cloud Code SDK is a powerful tool for putting together agents as you'll see as we progress.  
All the pieces are there and they're incrementally adoptable.

**05:56**  
And then lastly, we're just doing some logging. That's it.

**05:59**  
That's the end of our agent: a simple ~150 line Pong agent.  
Most of this is just logging.

---

## Advertencia: tocar system prompt cambia el producto

**06:24**  
This showcases the power of the system prompt.  
Remember all that work that the Claw Code team has put into making a great agent, right?  
The Claw Code agent that you know and love is now gone.

**06:34**  
You have to be very careful with the system prompt.  
We now have a new product. This is not Claw Code anymore.  
It might be using the same model, but the system prompt is truly what builds the agent.

**06:48**  
Now, of course, we are still using the tools.  
That's important to call out here as you'll see as we progress into more and more capable custom agents.

---

## Echo Agent (tooling + modelo + conversaciones)

**06:56**  
Let's move on to our second agent: the **Echo agent**.

**07:02**  
Inside of our Echo agent, you can see a similar structure.  
We have a single Python script that we're going to execute: `uv run echo_agent.py`.

**07:14**  
But here we have something different: a **custom tool**.  
Our agent is saying, "I'll use this tool."  
Then we have the tool call block, the response of the tool call, and then our agent response.

**07:31**  
You want to be keeping track of these. Keep track of the **core four**.  
If you understand the core four and how each element flows and controls your agent, you will understand compute and you'll understand how to scale your compute.

**07:44**  
Let's go ahead and echo ourselves:  
"Echo this string and then I want it in reverse in uppercase. Repeat two times."  
Here we're just playing with the tool that our custom agent has.

**08:05**  
We're scaling up a little more. We're adding a few more capabilities to our agent as we explore custom agents.

**08:13**  
Same structure: collapse everything and quickly understand what's going on.  
We have main, we have a tool, and we have our system prompt.  
Always look for the system prompt, then look for the custom tools.

**08:39**  
We have an MCP server built in this script—create SDK MCP server—and we're passing in a single tool.  
This builds an entire MCP server **in memory** for our agent.

**08:44**  
Tools for your Cloud Code SDK are built like this:

- a decorator  
- name  
- description  
- parameters  
- then return the result in the proper format

**09:30**  
We are running a cheaper, less intelligent, but much faster model.  
This is a simple agent. It doesn't need powerful intelligence—so we dropped down the model.

**10:05**  
Query is for one-off prompts and the SDK client is for continuous conversations.  
Using the SDK client, the agent can keep track of the conversation across follow-ups.

---

## Sobre tools: demasiadas herramientas consumen contexto

**11:44**  
If you run "list your available tools", you can still be running a lot of the baked-in tool set.  
These are all the Cloud Code tools plus our tool.

**12:01**  
Everything that's going into your agent winds up in the context window at some point.  
We have 15 extra tools, 15 extra options our agent has to choose from.

**12:12**  
Now, our Echo agent does not need any of these tools.  
As we progress, we're going to fine-tune and get more control over our agent.

**12:42**  
This is not the Claw Code product anymore.  
As soon as you touch the system prompt and start dialing into the tools, you change the product—you change the agent.

---

## Calc Agent (terminal UI + herramientas limitadas)

**13:38**  
Next, we have the **calc agent**.

**14:00**  
We have that prompts directory in every one of our custom agents.  
We're being consistent with our codebase—easy for us, our team, and most importantly our agents to read.

**14:22**  
The calc agent changes the form factor: a terminal UI.  
Ask: "What tools do you have available?"  
This agent only has **two tools**—a fine-grain focused agent.

**15:10**  
Most agents will be deployed in scripts, but you can also use agents in terminal UIs.  
And later you can build out full agents as backend methods, streamers, and processors.

**16:50**  
Important: you can disallow tools so they do **not** end up in the context window.  
Adopt your agent's perspective: if the tool isn't allowed, the agent can't see it.

**17:16**  
As usual:

1. configure options (core four minus the user prompt)  
2. mount the agent with the SDK  
3. run prompts  
4. manage responses and logs

**19:02**  
You can capture session id, costs, and continue sessions with a resume parameter—keeping a micro-agent conversation in the terminal.

---

## Social Hype Agent (stream processing + notify)

**21:28**  
Next, we have the **social hype agent**.

**22:13**  
This is a stream handler: it reads a websocket firehose, filters by keywords (deterministic), then calls the agent to do sentiment analysis.

**23:46**  
If the message matches notification criteria, it triggers an alert (tool call).  
It can text you, update Discord/Slack, speak via TTS—anything.

**24:33**  
Same analysis workflow:

- options / core four  
- system prompt (law of the agent)  
- tools (submit analysis, notify)  
- restrict tools to reduce context waste  
- monitoring loop + queue kicks off the agent

**26:29**  
System prompt includes:

- purpose (stream analysis, summaries, classify, decide notify)  
- instructions  
- workflow (controversial but valid if you want it to do the same thing every time)  
- tool usage requirements

**28:54**  
Key: remove unnecessary capabilities.  
Everything ends up in the context window—keep the agent focused:  
**one agent, one prompt, one purpose**.