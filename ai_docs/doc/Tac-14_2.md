# Class 2 & Class 3: Outloop Systems, ADWs, and the Orchestrator

## Hard Requirements

This requires a **high level of prompt engineering** and **context engineering**.

As discussed before:

- You have a full **mental model** that an agent is tracking.
- It knows where file references are.
- It understands the underlying responsibilities of a specific area of your codebase.
- And you surround that expert with prompts:
  - A **question prompt** to ask the expert questions while building or learning
  - A **plan prompt**
  - A **build prompt**
  - And you can **chain them together**

### The form factor doesn’t matter

It doesn’t matter if this is:

- A set of prompts
- A custom agent / sub-agent
- A skill
- A prime prompt

A “skill” is just a markdown file referencing other files.

You can compose everything by hand.

What matters is increasing your **compute advantage** with techniques like these.

This yields:

- **Self-improving expertise**
- **Specialized workflows** built on top of that expertise

This is what uniquely identifies:

> **Class 1 · Grade 7 Agentic Layer**  
> ✅ Experts embedded into your codebase

The question is simple:

> Do you have a specialized agent that can operate specific parts of your codebase **better than you**, increasingly so?

---

## The Next Step: Class 2 · Grade 1

The next few years of engineering will likely be spent building:

- Class 1
- Class 2
- Class 3

And that leads directly to:

> **Class 2 · Grade 1**

This is the “second tier.”

Class 2 Grade 1 is defined by one major change (from TAC Lesson 4):

> **ADWs (AI Developer Workflows)** — early-stage

You don’t have a full ADW yet, but you’re beginning to assemble the second layer.

### Class 2 = Layer 2

Class 2 is where you build an **outloop system**.

This is the **Peter framework**:

- You stay **out of the loop**
- Agents operate your codebase **without you**
- You build the fabric that enables this

Grade 1 is building that fabric.

---

## Class 2 · Grade 1: Webhooks + External Triggers

A barebones Class 2 Grade 1 system can be:

- A webhook (HTTP endpoint)
- Exposed with proper security
- Triggered by external services such as:
  - Slack
  - Jira
  - Discord
  - GitHub

In this setup:

- A webhook calls a prompt
- The prompt executes against your codebase via an agent SDK
- This kicks off custom agents specialized for one job each (Tactic 6)

You can add:

- Logging
- Investigation
- Telemetry
- Validation

Even before the full ADW system is present.

---

## The Codebase Grows Alongside the Agentic Layer

As your product grows:

- Your server grows (more models, routers, modules)
- Your client grows (more UI complexity)
- Your agentic layer grows **in parallel**

The goal is that:

> Your agents run the codebase, and you teach them to run it well.

Class 2 is where you stop wasting time on:

- small chores
- small bugs
- repetitive tasks

Because by this point, staying in the loop for those is a bottleneck.

---

## Programmatic Agents & Deterministic Orchestration

Class 2 pushes you into programmatic agents:

- You run agents through an SDK
- You build a deterministic scripting layer to orchestrate agents
- You prompt against the SDK
- You control the workflow execution programmatically

This is:

> **Outloop agentic coding**

---

## Class 2 · Grade 2: Full AI Developer Workflows (ADWs)

Grade 2 is defined by having true AI developer workflows:

- Specialized, end-to-end workflows
- Run against the application layer
- Operate through the agentic layer

This is where things go **parabolic**.

### Why Grade 2 is huge

Because you get:

- **Deterministic code**
- + **Non-deterministic agents**
- = **best of both worlds**

You gain full control between steps:

- Logging
- Validation
- Retries
- Event emitting (UI updates, comments, status)

You can emit progress via:

- WebSockets
- Polling
- GitHub comments
- PR updates
- Slack updates

At this stage, you have:

- Class 1 agentics (prompts, sub-agents, skills, closed-loops, chains)
- plus a real outloop system running workflows end-to-end

### Transition signal

A strong indicator you’re in Class 2 Grade 2:

> You start deleting prompt chains and replacing them with ADWs  
> (workflows with logging, observability, and control)

Many engineers will stop at a cloud tool built by a lab.

But if you build your own ADWs:

- you get more control
- you preserve your most valuable asset
- you truly own your codebase

---

## Class 3: The Orchestrator Agent

Now we move to the final class.

Class 3 is defined by one thing:

> **The orchestrator agent**  
> “The one agent to rule them all.”

Class 3 includes everything from previous classes:

- Class 1 foundations
- Class 2 outloop systems

And adds an orchestrator layer on top.

### Where does the orchestrator live?

Not fully settled—options include:

- A dedicated orchestrator application that references ADWs
- Embedded directly inside the ADW system

Either way, it gets hard:

- Complex maintenance
- Orchestrating orchestration
- Higher engineering burden

But the impact is absurd.

The orchestrator is a custom agent that acts like a lead engineer:

- It can CRUD, command, and manage other agents
- It centralizes control over the agentic layer
- It can run outloop or in-loop (terminal), but best is outloop

---

## Orchestrator Developer Workflows

Once you have an orchestrator, you can build:

> **Orchestrator Developer Workflows**

These feel like:

- Prompt chains
- ADWs

…but they’re more powerful because the orchestrator understands:

- your agents
- your prompts
- your skills
- your experts
- your workflows

It can:

- Spin up teams of agents
- Track and summarize logs
- Maintain open communication streams
- Let you interrogate any agent mid-flight

You preserve Tactic 6 at scale:

> One agent · one prompt · one purpose

---

## Class 3 · Grade 3: Orchestrator + ADWs = Final Level

The final stage is reached when:

- Your orchestrator can run AI developer workflows
- You can track, observe, control, validate everything
- You have a UI / system for monitoring pipelines end-to-end
- You move toward **zero-touch engineering**

This is:

> **Class 3 · Grade 3**

And it brings you to the doorstep of:

- Zero-touch engineering
- The codebase singularity

---

## The Point of the Framework

The goal is not “always climb to the highest class.”

The goal is:

1. Identify where you are (class + grade)
2. Identify what’s missing
3. Build a roadmap
4. Test and iterate

Transitions are real:

- Class 1 → Class 2: out of the terminal, out of the loop  
- Class 2 → Class 3: orchestrated agentic coding  

All roads lead to the same north star:

> **Zero-touch engineering → Codebase singularity**

---

## What We Learned Across TAC + Agentic Horizon

### 1) Stop hand-coding when agents are the best tool
If you keep writing everything by hand, you won’t reach a complex agentic layer.

### 2) Adopt the agent’s perspective
Before you hit enter, ask:

> With this context, could I solve the problem?

### 3) Template your engineering
Without templates, agents drift.

Templates encode best practices:

- “This is how we solve bugs”
- “This is how we build endpoints”
- “This is how we integrate XYZ”

### 4) Stay out of the loop
If you’re stuck in the terminal prompting forever, you won’t scale.

### 5) Always add feedback loops
More compute should mean more trust:

- Request
- Validate
- Resolve

### 6) One agent · one prompt · one purpose
Focus increases performance—especially with limited context windows.

### 7) Target zero-touch engineering
Not a meme anymore—some engineers do it today.

There is a configuration of the agentic layer that can exist right now:

> So powerful your codebase runs itself.

But you must aim at it.

---

## Meta-Tactic

Everything collapses into one idea:

> **Prioritize agentics.**  
> **Build the system that builds the system.**

---

## Closing

Tools will change. Models will change.

But the skills you have now—prompting, context, workflows, orchestration, experts—are the foundation for winning in the age of agents.

> When the agents arrived, something changed.  
> We weren’t just AI coding anymore.  
> We started orchestrating intelligence.

If you apply these ideas and really put them to work:

> It will change everything.