#!/usr/bin/env -S uv run
# /// script
# dependencies = ["python-dotenv", "pydantic", "boto3>=1.26.0"]
# ///

"""
ADW Review Iso - AI Developer Workflow for agentic review in isolated worktrees

Usage:
  uv run adw_review_iso.py <issue-number> <adw-id> [--skip-resolution]

Workflow:
1. Load state and validate worktree exists
2. Find spec file from worktree
3. Review implementation against specification in worktree
4. Capture screenshots of critical functionality
5. If issues found and --skip-resolution not set:
   - Create patch plans for issues
   - Implement resolutions
6. Post results as commit message
7. Commit review results in worktree
8. Push and update PR

This workflow REQUIRES that adw_plan_iso.py or adw_patch_iso.py has been run first
to create the worktree. It cannot create worktrees itself.
"""

import sys
import os
import logging
import json
from typing import Optional, List
from dotenv import load_dotenv

from adw_modules.state import ADWState
from adw_modules.git_ops import commit_changes, finalize_git_operations
from adw_modules.github import (
    fetch_issue,
    make_issue_comment,
    get_repo_url,
    extract_repo_path,
)
from adw_modules.workflow_ops import (
    create_commit,
    format_issue_message,
    implement_plan,
    find_spec_file,
)
from adw_modules.utils import setup_logger, parse_json, check_env_vars
from adw_modules.data_types import (
    AgentTemplateRequest,
    ReviewResult,
    ReviewIssue,
    AgentPromptResponse,
)
from adw_modules.agent import execute_template
from adw_modules.r2_uploader import R2Uploader
from adw_modules.worktree_ops import validate_worktree

AGENT_REVIEWER = "reviewer"
AGENT_REVIEW_PATCH_PLANNER = "review_patch_planner"
AGENT_REVIEW_PATCH_IMPLEMENTOR = "review_patch_implementor"

MAX_REVIEW_RETRY_ATTEMPTS = 3


def run_review(
    spec_file: str,
    adw_id: str,
    logger: logging.Logger,
    working_dir: Optional[str] = None,
) -> ReviewResult:
    """Run the review using the /review command."""
    request = AgentTemplateRequest(
        agent_name=AGENT_REVIEWER,
        slash_command="/review",
        args=[adw_id, spec_file, AGENT_REVIEWER],
        adw_id=adw_id,
        working_dir=working_dir,
    )

    response = execute_template(request)

    if not response.success:
        logger.error(f"Review failed: {response.output}")
        return ReviewResult(
            success=False,
            review_summary=f"Review failed: {response.output}",
            review_issues=[],
            screenshots=[],
            screenshot_urls=[],
        )

    try:
        result = parse_json(response.output, ReviewResult)
        return result
    except Exception as e:
        logger.error(f"Error parsing review result: {e}")
        return ReviewResult(
            success=False,
            review_summary=f"Error parsing review result: {e}",
            review_issues=[],
            screenshots=[],
            screenshot_urls=[],
        )


def build_review_summary(review_result: ReviewResult) -> str:
    """Build a formatted summary of the review results for GitHub comment."""
    summary_parts = [f"## Review Summary\n\n{review_result.review_summary}"]

    if review_result.review_issues:
        summary_parts.append("\n## Issues Found")

        blockers = [i for i in review_result.review_issues if i.issue_severity == "blocker"]
        tech_debts = [i for i in review_result.review_issues if i.issue_severity == "tech_debt"]
        skippables = [i for i in review_result.review_issues if i.issue_severity == "skippable"]

        if blockers:
            summary_parts.append(f"\n### Blockers ({len(blockers)})")
            for issue in blockers:
                summary_parts.append(f"- **Issue {issue.review_issue_number}**: {issue.issue_description}")
                summary_parts.append(f"  - Resolution: {issue.issue_resolution}")

        if tech_debts:
            summary_parts.append(f"\n### Tech Debt ({len(tech_debts)})")
            for issue in tech_debts:
                summary_parts.append(f"- **Issue {issue.review_issue_number}**: {issue.issue_description}")
                summary_parts.append(f"  - Resolution: {issue.issue_resolution}")

        if skippables:
            summary_parts.append(f"\n### Skippable ({len(skippables)})")
            for issue in skippables:
                summary_parts.append(f"- **Issue {issue.review_issue_number}**: {issue.issue_description}")
                summary_parts.append(f"  - Resolution: {issue.issue_resolution}")

    if review_result.screenshot_urls:
        summary_parts.append(f"\n## Screenshots")
        summary_parts.append(f"Captured {len(review_result.screenshot_urls)} screenshots\n")
        for i, screenshot_url in enumerate(review_result.screenshot_urls):
            if screenshot_url.startswith("http"):
                summary_parts.append(f"### Screenshot {i+1}")
                summary_parts.append(f"![Screenshot {i+1}]({screenshot_url})\n")
            else:
                summary_parts.append(f"- Screenshot {i+1}: `{screenshot_url}`")

    return "\n".join(summary_parts)


def main():
    """Main entry point."""
    load_dotenv()

    skip_resolution = "--skip-resolution" in sys.argv
    if skip_resolution:
        sys.argv.remove("--skip-resolution")

    if len(sys.argv) < 3:
        print("Usage: uv run adw_review_iso.py <issue-number> <adw-id> [--skip-resolution]")
        print("\nError: adw-id is required to locate the worktree")
        print("Run adw_plan_iso.py or adw_patch_iso.py first to create the worktree")
        sys.exit(1)

    issue_number = sys.argv[1]
    adw_id = sys.argv[2]

    temp_logger = setup_logger(adw_id, "adw_review_iso")
    state = ADWState.load(adw_id, temp_logger)
    if state:
        issue_number = state.get("issue_number", issue_number)
        make_issue_comment(
            issue_number,
            f"{adw_id}_ops: Found existing state - starting isolated review\n```json\n{json.dumps(state.data, indent=2)}\n```"
        )
    else:
        logger = setup_logger(adw_id, "adw_review_iso")
        logger.error(f"No state found for ADW ID: {adw_id}")
        print(f"\nError: No state found for ADW ID: {adw_id}")
        sys.exit(1)

    state.append_adw_id("adw_review_iso")

    logger = setup_logger(adw_id, "adw_review_iso")
    logger.info(f"ADW Review Iso starting - ID: {adw_id}, Issue: {issue_number}, Skip Resolution: {skip_resolution}")

    check_env_vars(logger)

    valid, error = validate_worktree(adw_id, state)
    if not valid:
        logger.error(f"Worktree validation failed: {error}")
        make_issue_comment(
            issue_number,
            format_issue_message(adw_id, "ops", f"Worktree validation failed: {error}")
        )
        sys.exit(1)

    worktree_path = state.get("worktree_path")
    logger.info(f"Using worktree at: {worktree_path}")

    backend_port = state.get("backend_port", "9100")
    frontend_port = state.get("frontend_port", "9200")

    make_issue_comment(
        issue_number,
        format_issue_message(adw_id, "ops", f"Starting isolated review phase\n"
                           f"Worktree: {worktree_path}\n"
                           f"Ports - Backend: {backend_port}, Frontend: {frontend_port}\n"
                           f"Issue Resolution: {'Disabled' if skip_resolution else 'Enabled'}")
    )

    logger.info("Looking for spec file in worktree")
    spec_file = find_spec_file(state, logger)

    if not spec_file:
        error_msg = "Could not find spec file for review"
        logger.error(error_msg)
        make_issue_comment(issue_number, format_issue_message(adw_id, "ops", f"{error_msg}"))
        sys.exit(1)

    logger.info(f"Found spec file: {spec_file}")
    make_issue_comment(issue_number, format_issue_message(adw_id, "ops", f"Found spec file: {spec_file}"))

    review_attempt = 0
    review_result = None

    while review_attempt < MAX_REVIEW_RETRY_ATTEMPTS:
        review_attempt += 1

        logger.info(f"Running review (attempt {review_attempt}/{MAX_REVIEW_RETRY_ATTEMPTS})")
        make_issue_comment(
            issue_number,
            format_issue_message(adw_id, AGENT_REVIEWER, f"Reviewing implementation against spec (attempt {review_attempt}/{MAX_REVIEW_RETRY_ATTEMPTS})...")
        )

        review_result = run_review(spec_file, adw_id, logger, working_dir=worktree_path)

        blocker_issues = [
            issue for issue in review_result.review_issues
            if issue.issue_severity == "blocker"
        ]

        if not blocker_issues or skip_resolution:
            break

        if review_attempt >= MAX_REVIEW_RETRY_ATTEMPTS - 1:
            break

        logger.info("Retrying review after resolving blockers")

    if review_result:
        summary = build_review_summary(review_result)
        make_issue_comment(issue_number, format_issue_message(adw_id, AGENT_REVIEWER, summary))

    try:
        github_repo_url = get_repo_url()
        repo_path = extract_repo_path(github_repo_url)
    except ValueError as e:
        logger.error(f"Error getting repository URL: {e}")
        sys.exit(1)

    logger.info("Fetching issue data for commit message")
    issue = fetch_issue(issue_number, repo_path)

    issue_command = state.get("issue_class", "/feature")

    logger.info("Creating review commit")
    commit_msg, error = create_commit(AGENT_REVIEWER, issue, issue_command, adw_id, logger, worktree_path)

    if error:
        logger.error(f"Error creating commit message: {error}")
        sys.exit(1)

    success, error = commit_changes(commit_msg, cwd=worktree_path)

    if not success:
        logger.error(f"Error committing review: {error}")
        sys.exit(1)

    logger.info(f"Committed review: {commit_msg}")
    make_issue_comment(issue_number, format_issue_message(adw_id, AGENT_REVIEWER, "Review committed"))

    finalize_git_operations(state, logger, cwd=worktree_path)

    logger.info("Isolated review phase completed successfully")
    make_issue_comment(issue_number, format_issue_message(adw_id, "ops", "Isolated review phase completed"))

    state.save("adw_review_iso")

    make_issue_comment(
        issue_number,
        f"{adw_id}_ops: Final review state:\n```json\n{json.dumps(state.data, indent=2)}\n```"
    )


if __name__ == "__main__":
    main()
