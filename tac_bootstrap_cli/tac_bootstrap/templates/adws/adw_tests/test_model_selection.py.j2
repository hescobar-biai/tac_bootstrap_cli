#!/usr/bin/env python3
"""Test model selection functionality for ADW workflows."""

import sys
import os
from typing import Dict, List

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from adw_modules.agent import (
    get_model_for_slash_command,
    SLASH_COMMAND_MODEL_MAP,
    MODEL_FALLBACK_CHAIN,
    get_fallback_model,
    is_quota_exhausted_error,
)
from adw_modules.data_types import AgentTemplateRequest, RetryCode


def test_model_mapping_structure():
    """Test that the model mapping structure is correct."""
    print("Testing model mapping structure...")

    # Check that all commands have both base and heavy mappings
    missing_base = []
    missing_heavy = []

    for command, config in SLASH_COMMAND_MODEL_MAP.items():
        if "base" not in config:
            missing_base.append(command)
        if "heavy" not in config:
            missing_heavy.append(command)

    if missing_base:
        print(f"FAIL Commands missing 'base' mapping: {missing_base}")
    else:
        print("PASS All commands have 'base' mapping")

    if missing_heavy:
        print(f"FAIL Commands missing 'heavy' mapping: {missing_heavy}")
    else:
        print("PASS All commands have 'heavy' mapping")

    return len(missing_base) == 0 and len(missing_heavy) == 0


def test_model_mapping_lookups():
    """Test model mapping lookups directly from SLASH_COMMAND_MODEL_MAP."""
    print("\nTesting model mapping lookups...")

    test_cases = [
        # (command, model_set, expected)
        ("/implement", "base", "sonnet"),
        ("/implement", "heavy", "opus"),
        ("/classify_issue", "base", "sonnet"),
        ("/classify_issue", "heavy", "sonnet"),  # Both use sonnet
        ("/review", "base", "sonnet"),
        ("/review", "heavy", "sonnet"),  # Both use sonnet
    ]

    all_passed = True
    for command, model_set, expected in test_cases:
        config = SLASH_COMMAND_MODEL_MAP.get(command, {})
        result = config.get(model_set, "unknown")
        if result == expected:
            print(f"PASS {command} with {model_set} -> {result}")
        else:
            print(f"FAIL {command} with {model_set} -> {result} (expected {expected})")
            all_passed = False

    return all_passed


def test_model_differences():
    """Show which commands use different models in heavy vs base."""
    print("\nCommands with different models in base vs heavy:")

    differences = []
    for command, config in SLASH_COMMAND_MODEL_MAP.items():
        base_model = config.get("base", "unknown")
        heavy_model = config.get("heavy", "unknown")
        if base_model != heavy_model:
            differences.append(f"  {command}: base={base_model}, heavy={heavy_model}")

    if differences:
        print("\n".join(differences))
    else:
        print("  (none - all commands use same model in both sets)")

    print(f"\nTotal commands with differences: {len(differences)}/{len(SLASH_COMMAND_MODEL_MAP)}")


def test_get_model_for_slash_command():
    """Test the get_model_for_slash_command function."""
    print("\nTesting get_model_for_slash_command...")

    # Create a mock ADW state
    from adw_modules.state import ADWState

    # Test with base model set
    test_adw_id = "test1234"
    state = ADWState(test_adw_id)
    state.update(model_set="base")
    state.save("test")

    request = AgentTemplateRequest(
        agent_name="test",
        slash_command="/implement",
        args=["plan.md"],
        adw_id=test_adw_id
    )

    model = get_model_for_slash_command(request)
    expected_base = "sonnet"
    if model == expected_base:
        print(f"PASS With model_set='base': /implement -> {model}")
    else:
        print(f"FAIL With model_set='base': /implement -> {model} (expected {expected_base})")

    # Test with heavy model set
    state.update(model_set="heavy")
    state.save("test")

    # Force reload the state by creating a new request
    model = get_model_for_slash_command(request)
    expected_heavy = "opus"
    if model == expected_heavy:
        print(f"PASS With model_set='heavy': /implement -> {model}")
    else:
        print(f"FAIL With model_set='heavy': /implement -> {model} (expected {expected_heavy})")

    # Test with no state (should default to base)
    request_no_state = AgentTemplateRequest(
        agent_name="test",
        slash_command="/review",
        args=["spec.md"],
        adw_id="nonexistent"
    )

    model = get_model_for_slash_command(request_no_state)
    expected_default = "sonnet"
    if model == expected_default:
        print(f"PASS With no state: /review -> {model} (default to base)")
    else:
        print(f"FAIL With no state: /review -> {model} (expected {expected_default})")

    # Clean up test state
    state_file = os.path.join(
        os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
        "agents", test_adw_id, "adw_state.json"
    )
    if os.path.exists(state_file):
        os.remove(state_file)
        # Try to remove empty directories
        try:
            os.rmdir(os.path.dirname(state_file))
            os.rmdir(os.path.dirname(os.path.dirname(state_file)))
        except:
            pass

    return True


def test_model_fallback_chain():
    """Test the model fallback chain for quota exhausted scenarios."""
    print("\nTesting model fallback chain...")

    all_passed = True

    # Test fallback chain
    test_cases = [
        ("opus", "sonnet"),
        ("sonnet", "haiku"),
        ("haiku", None),  # No fallback from haiku
    ]

    for current_model, expected_fallback in test_cases:
        result = get_fallback_model(current_model)
        if result == expected_fallback:
            print(f"PASS {current_model} -> {result}")
        else:
            print(f"FAIL {current_model} -> {result} (expected {expected_fallback})")
            all_passed = False

    return all_passed


def test_quota_exhausted_detection():
    """Test detection of quota exhausted errors."""
    print("\nTesting quota exhausted error detection...")

    all_passed = True

    # Test cases: (error_message, expected_is_quota_exhausted)
    test_cases = [
        ("You've hit your limit - resets 1pm (America/Bogota)", True),
        ("Rate limit exceeded, try again later", False),  # Rate limit, not quota
        ("Usage limit reached for this billing period", True),
        ("Error 429: Too many requests", False),  # Rate limit
        ("Monthly limit exceeded", True),
        ("Connection timeout", False),
        ("quota exceeded for model", True),
    ]

    for error_msg, expected in test_cases:
        result = is_quota_exhausted_error(error_msg)
        if result == expected:
            status = "quota" if result else "not quota"
            print(f"PASS \"{error_msg[:50]}...\" -> {status}")
        else:
            print(f"FAIL \"{error_msg[:50]}...\" -> {result} (expected {expected})")
            all_passed = False

    return all_passed


def test_retry_code_quota_exhausted():
    """Test that RetryCode.QUOTA_EXHAUSTED exists."""
    print("\nTesting RetryCode.QUOTA_EXHAUSTED...")

    try:
        code = RetryCode.QUOTA_EXHAUSTED
        print(f"PASS RetryCode.QUOTA_EXHAUSTED exists: {code.value}")
        return True
    except AttributeError:
        print("FAIL RetryCode.QUOTA_EXHAUSTED does not exist")
        return False


def main():
    """Run all tests."""
    print("ADW Model Selection Tests")
    print("=" * 50)

    all_tests_passed = True

    # Run tests
    if not test_model_mapping_structure():
        all_tests_passed = False

    if not test_model_mapping_lookups():
        all_tests_passed = False

    test_model_differences()

    if not test_get_model_for_slash_command():
        all_tests_passed = False

    if not test_model_fallback_chain():
        all_tests_passed = False

    if not test_quota_exhausted_detection():
        all_tests_passed = False

    if not test_retry_code_quota_exhausted():
        all_tests_passed = False

    print("\n" + "=" * 50)
    if all_tests_passed:
        print("All tests passed!")
        return 0
    else:
        print("Some tests failed!")
        return 1


if __name__ == "__main__":
    sys.exit(main())
