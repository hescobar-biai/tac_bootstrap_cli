# Generated by {{ config.project.name }} - Standardized Response Models
# This template provides consistent API response structures

"""
IDK: api-responses, pagination, error-handling, http-responses, openapi-schema

Module: responses

Responsibility:
- Provide standardized Pydantic models for API responses
- Enforce consistent structure across all endpoints
- Enable automatic OpenAPI schema generation
- Support pagination with automatic page count calculation
- Define success and error response formats

Key Components:
- PaginatedResponse[T]: Generic pagination model for list endpoints
- SuccessResponse: Standard success confirmation format
- ErrorResponse: Structured error response container
- ErrorDetail: Nested error information with type, message, and details

Invariants:
- PaginatedResponse uses 1-indexed pagination (page >= 1)
- page_size is constrained between 1 and 100
- pages field is automatically calculated as ceil(total / page_size)
- pages = 0 when total = 0
- Out-of-range page numbers return empty data list (graceful, no error)
- ErrorResponse always contains nested ErrorDetail object
- SuccessResponse.success is always True

Usage Examples:

```python
# Example 1: Paginated list endpoint
from pydantic import BaseModel
from src.shared.infrastructure.responses import PaginatedResponse, SuccessResponse

class ProductResponse(BaseModel):
    id: str
    name: str
    price: float

@router.get("/products", response_model=PaginatedResponse[ProductResponse])
def list_products(page: int = 1, page_size: int = 10):
    products = repository.find_all(page, page_size)
    total = repository.count()

    return PaginatedResponse(
        data=[ProductResponse.model_validate(p) for p in products],
        total=total,
        page=page,
        page_size=page_size
        # pages calculated automatically!
    )

# Example 2: Success response for DELETE operation
@router.delete("/products/{id}", response_model=SuccessResponse)
def delete_product(id: str):
    repository.delete(id)
    return SuccessResponse(message=f"Product {id} deleted successfully")

# Example 3: Error response (auto-generated by exception handlers)
# Exception handlers from exceptions.py return ErrorResponse automatically:
# {
#   "error": {
#     "type": "EntityNotFoundError",
#     "message": "Product with id 'abc123' not found",
#     "details": {"entity_type": "Product", "entity_id": "abc123"}
#   }
# }
```

Collaborators:
- Pydantic BaseModel: validation and serialization
- FastAPI routes: use with response_model parameter
- Service layer: returns response model instances
- Exception handlers: generate ErrorResponse format
- OpenAPI: auto-generates schemas from response models

Failure Modes:
- ValidationError if page < 1 (1-indexed pagination)
- ValidationError if page_size < 1 or page_size > 100
- ValidationError if total < 0
- No error if page > pages (returns empty data list gracefully)

Related Docs:
- docs/shared/infrastructure/responses.md
- ai_docs/doc/create-crud-entity/
"""

from typing import Generic, TypeVar, Any
from pydantic import BaseModel, Field, computed_field
from math import ceil

T = TypeVar("T")


class PaginatedResponse(BaseModel, Generic[T]):
    """
    IDK: pagination, list-endpoint, page-calculation, openapi-generic

    Responsibility:
    - Provide type-safe generic pagination model
    - Automatically calculate total pages from total and page_size
    - Validate pagination parameters (1-indexed, page_size 1-100)
    - Support any item type via generic parameter T

    Generic Type Parameter:
    - T: The type of items in the data list (e.g., ProductResponse, UserResponse)
    - Provides type safety and IDE autocomplete
    - FastAPI generates specific OpenAPI schema based on T

    Fields:
    - data: list[T] - The paginated items for current page
    - total: int - Total count of items across all pages (>= 0)
    - page: int - Current page number (1-indexed, >= 1)
    - page_size: int - Items per page (1-100)
    - pages: int - Total pages (computed automatically)

    Pagination Rules:
    - Uses 1-indexed pagination (page 1 is first page)
    - page_size limited to 1-100 to prevent abuse
    - pages calculated as ceil(total / page_size)
    - Empty data for out-of-range pages (page > pages returns [])

    Edge Cases:
    - total=0 → pages=0, data=[]
    - page > pages → data=[] (graceful, no error)
    - total=10, page_size=10 → pages=1
    - total=11, page_size=10 → pages=2 (ceil division)

    Usage Example:

    ```python
    class ProductResponse(BaseModel):
        id: str
        name: str
        price: float

    @router.get("/products", response_model=PaginatedResponse[ProductResponse])
    def list_products(page: int = 1, page_size: int = 10):
        products = repository.find_all(page, page_size)
        total = repository.count()

        return PaginatedResponse(
            data=[ProductResponse.model_validate(p) for p in products],
            total=total,
            page=page,
            page_size=page_size
        )
    ```

    Database Integration:

    ```python
    # Convert page/page_size to database OFFSET/LIMIT
    offset = (page - 1) * page_size
    limit = page_size
    products = db.query(Product).offset(offset).limit(limit).all()
    ```

    Collaborators:
    - Pydantic Generic: enables type parameter T
    - computed_field: calculates pages automatically
    - FastAPI: generates OpenAPI schema from Generic[T]

    Failure Modes:
    - ValidationError if page < 1
    - ValidationError if page_size < 1 or > 100
    - ValidationError if total < 0

    Related Docs:
    - docs/shared/infrastructure/pagination.md
    """

    data: list[T] = Field(
        ...,
        description="List of items for the current page"
    )

    total: int = Field(
        ...,
        ge=0,
        description="Total count of items across all pages"
    )

    page: int = Field(
        ...,
        ge=1,
        description="Current page number (1-indexed)"
    )

    page_size: int = Field(
        ...,
        ge=1,
        le=100,
        description="Number of items per page (1-100)"
    )

    @computed_field
    @property
    def pages(self) -> int:
        """
        Calculate total number of pages.

        Returns 0 if total is 0, otherwise ceil(total / page_size).
        This ensures:
        - Empty dataset has 0 pages
        - Partial last page counted (e.g., 11 items with page_size=10 → 2 pages)
        """
        if self.total == 0:
            return 0
        return ceil(self.total / self.page_size)


class SuccessResponse(BaseModel):
    """
    IDK: success-response, operation-confirmation, http-200

    Responsibility:
    - Provide standard format for successful operation confirmations
    - Return human-readable success messages
    - Indicate operation completion without returning entity data

    Fields:
    - success: bool - Always True (explicit confirmation)
    - message: str - Human-readable success message

    Use Cases:
    - DELETE operations: "Product deleted successfully"
    - POST operations: "Product created successfully"
    - PUT/PATCH operations: "Product updated successfully"
    - Batch operations: "5 products updated successfully"
    - Admin actions: "Cache cleared successfully"

    Design Note:
    - success field is always True (redundant but explicit)
    - Some API consumers check success field programmatically
    - Consistent structure: error has error field, success has success field

    Usage Example:

    ```python
    @router.delete("/products/{id}", response_model=SuccessResponse)
    def delete_product(id: str):
        repository.delete(id)
        return SuccessResponse(message=f"Product {id} deleted successfully")

    @router.post("/products/batch-update", response_model=SuccessResponse)
    def batch_update(ids: list[str], data: ProductUpdate):
        count = service.batch_update(ids, data)
        return SuccessResponse(message=f"{count} products updated successfully")
    ```

    Collaborators:
    - FastAPI routes: use with response_model parameter
    - Service layer: returns SuccessResponse instances

    Related Docs:
    - docs/shared/infrastructure/responses.md
    """

    success: bool = Field(
        default=True,
        description="Operation success indicator (always True)"
    )

    message: str = Field(
        ...,
        description="Human-readable success message"
    )


class ErrorDetail(BaseModel):
    """
    IDK: error-detail, error-structure, exception-info

    Responsibility:
    - Provide structured error information
    - Support multiple error types from exceptions.py
    - Include optional additional error details

    Fields:
    - type: str - Error type identifier (e.g., "EntityNotFoundError")
    - message: str - Human-readable error message
    - details: dict[str, Any] | None - Optional structured error details

    Common Error Types (from exceptions.py):
    - "EntityNotFoundError": Resource not found (404)
    - "DuplicateEntityError": Uniqueness violation (409)
    - "DomainValidationError": Business rule violation (400)
    - "UnauthorizedError": Authentication required (401)
    - "ForbiddenError": Insufficient permissions (403)
    - "BusinessRuleError": Business logic violation (400)
    - "InternalServerError": Unexpected server error (500)
    - "validation_error": Pydantic validation failure (422)

    Details Field Usage:
    - Validation errors: {"field": "email", "errors": ["Invalid format"]}
    - Not found errors: {"entity_type": "Product", "entity_id": "abc123"}
    - Duplicate errors: {"field": "code", "value": "PROD-001"}
    - Generic context: {"request_id": "...", "timestamp": "..."}

    Security Note:
    - Do not include sensitive data in details (passwords, tokens)
    - Error messages should be user-friendly but not reveal internal structure

    Usage Example:

    ```python
    # Exception handler returns ErrorDetail
    ErrorDetail(
        type="EntityNotFoundError",
        message="Product with id 'abc123' not found",
        details={"entity_type": "Product", "entity_id": "abc123"}
    )

    # Validation error with field-specific details
    ErrorDetail(
        type="validation_error",
        message="Invalid product data",
        details={
            "errors": [
                {"field": "price", "message": "Must be greater than 0"},
                {"field": "name", "message": "Cannot be empty"}
            ]
        }
    )
    ```

    Collaborators:
    - ErrorResponse: wraps ErrorDetail
    - Exception handlers: generate ErrorDetail from exceptions

    Related Docs:
    - docs/shared/infrastructure/error-handling.md
    """

    type: str = Field(
        ...,
        min_length=1,
        description="Error type identifier"
    )

    message: str = Field(
        ...,
        min_length=1,
        description="Human-readable error message"
    )

    details: dict[str, Any] | None = Field(
        default=None,
        description="Optional structured error details"
    )


class ErrorResponse(BaseModel):
    """
    IDK: error-response, exception-handler, http-error

    Responsibility:
    - Provide consistent error response structure
    - Wrap ErrorDetail in standard envelope
    - Work with exception handlers from exceptions.py

    Fields:
    - error: ErrorDetail - Nested error object with type, message, details

    Design Note:
    - Consistent format across all errors
    - Exception handlers automatically convert exceptions to ErrorResponse
    - Frontend can rely on predictable error structure

    Usage Example:

    ```python
    # Exception handlers return ErrorResponse automatically
    @app.exception_handler(EntityNotFoundError)
    async def not_found_handler(request: Request, exc: EntityNotFoundError):
        return JSONResponse(
            status_code=404,
            content=ErrorResponse(
                error=ErrorDetail(
                    type="EntityNotFoundError",
                    message=exc.message,
                    details={"entity_type": exc.entity_type, "entity_id": exc.entity_id}
                )
            ).model_dump()
        )

    # Frontend receives:
    # {
    #   "error": {
    #     "type": "EntityNotFoundError",
    #     "message": "Product with id 'abc123' not found",
    #     "details": {"entity_type": "Product", "entity_id": "abc123"}
    #   }
    # }
    ```

    Collaborators:
    - ErrorDetail: nested error information
    - Exception handlers: generate ErrorResponse from exceptions
    - FastAPI: returns as JSON response with appropriate status code

    Related Docs:
    - docs/shared/infrastructure/error-handling.md
    - docs/shared/api/exceptions.md
    """

    error: ErrorDetail = Field(
        ...,
        description="Structured error information"
    )
