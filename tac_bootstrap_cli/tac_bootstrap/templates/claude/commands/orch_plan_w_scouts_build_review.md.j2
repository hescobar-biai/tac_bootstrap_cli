---
allowed-tools:
  - Task
  - Read
  - TodoWrite
  - AskUserQuestion
description: Complete workflow orchestrating scout, plan, build, and review phases
argument-hint: "[task_description]"
model: sonnet
category: Orchestrator Commands
---

# Plan with Scouts ‚Üí Build ‚Üí Review Orchestrator

Execute a complete end-to-end workflow by orchestrating four sequential phases: parallel scout exploration, implementation planning, code generation, and quality review. This command automates the entire development cycle from discovery through validation.

## Variables

TASK_DESCRIPTION: $1 (required - description of what to implement)

## Purpose

The `/orch_plan_w_scouts_build_review` command provides full-pipeline automation by:
- Discovering all files relevant to your task through parallel scout exploration
- Creating a comprehensive implementation plan based on scout findings
- Executing the plan sequentially with clear progress tracking
- Conducting a quality review of the implementation
- Handling errors at each phase with fail-fast behavior

## When to Use This Command

Use `/orch_plan_w_scouts_build_review` when:
- Starting a complete feature implementation from scratch requiring comprehensive analysis
- You want to go from task description to validated code in one workflow
- You need thorough file discovery, planning, implementation, and review
- You want automated orchestration without manual phase coordination
- Quality assurance is critical and you want built-in review

## When NOT to Use This Command

Do NOT use `/orch_plan_w_scouts_build_review` when:
- You already know which files to modify (use `/plan` + `/build` directly)
- You only need file discovery (use `/scout` alone)
- You only need a plan without implementation (use `/plan` alone)
- The task is trivial or single-file (use direct editing)
- You want to review/adjust the plan before building (use `/scout` + `/plan`, then `/build` separately)
- You want to skip the review phase (use `/scout_plan_build` instead)

## Workflow Phases

**Phase 1: Scout (Parallel Exploration)**
- Launches parallel exploration agents with different search strategies
- Uses Glob for file patterns, Grep for content search, Read for analysis
- Aggregates results with relevance scoring
- Read-only codebase analysis

**Phase 2: Plan (Implementation Planning)**
- Uses scout results to inform planning
- Creates structured implementation plan with file list, tasks, and acceptance criteria
- Identifies files to modify and create
- Defines step-by-step tasks and validation commands

**Phase 3: Build (Sequential Implementation)**
- Implements the plan step-by-step
- Shows clear progress for each step
- Validates changes incrementally
- Reports implementation status

**Phase 4: Review (Quality Assessment)**
- Reviews implementation for code quality, best practices, and completeness
- Validates against acceptance criteria from plan
- Identifies potential issues or improvements
- Provides actionable feedback

## Instructions

### Step 1: Initialize Todo List

Create todo list to track the 4-phase workflow:

```
Use TodoWrite tool to create:
- üîç Scout Phase: Parallel codebase exploration
- üìã Plan Phase: Implementation planning
- üî® Build Phase: Sequential implementation
- ‚úÖ Review Phase: Quality assessment
```

Set first todo (Scout Phase) to `in_progress`.

### Step 2: Validate Input Parameters

Extract and validate TASK_DESCRIPTION:

- Extract TASK_DESCRIPTION from $1
- If TASK_DESCRIPTION is missing or empty:
  - Report error: "ERROR: TASK_DESCRIPTION is required. Usage: /orch_plan_w_scouts_build_review \"task description\""
  - STOP - do not continue

### Step 3: Launch Scout Phase

Output progress message:
```
=== PHASE 1/4: SCOUT ===
Launching parallel codebase exploration...
Task: {TASK_DESCRIPTION}
```

Launch scout agent using Task tool:
- `subagent_type: "scout-report-suggest"`
- `model: "haiku"` (fast, cost-effective)
- `description: "Scout: parallel exploration"`
- `prompt`:
```
Find all files relevant to: {TASK_DESCRIPTION}

Use parallel exploration strategies:
- File pattern search (Glob for naming conventions and directory structure)
- Content search (Grep for keywords, functions, classes, imports)
- Architectural analysis (Read to understand module relationships)
- Dependency mapping (cross-file references)

Aggregate results with frequency-based relevance scoring.
List all relevant files with brief relevance notes.
Use thoroughness level: medium
```

Wait for scout agent to complete.

If scout fails:
- Report error: "ERROR: Scout phase failed. Unable to explore codebase."
- Show scout error details
- Mark scout todo as failed
- STOP - do not continue to plan phase

Mark scout todo as completed, set plan todo to `in_progress`.

### Step 4: Process Scout Results and Launch Plan Phase

Output progress message:
```
=== PHASE 2/4: PLAN ===
Creating implementation plan based on scout findings...
```

Parse scout agent output to extract:
- List of relevant files found
- Relevance notes and context for each file
- Architectural patterns identified

Launch plan agent using Task tool:
- `subagent_type: "planner"`
- `model: "opus"` (high-quality planning)
- `description: "Plan: implementation planning"`
- `prompt`:
```
Create an implementation plan for: {TASK_DESCRIPTION}

Scout exploration found these relevant files:
{scout_results_summary}

Follow the planning workflow:
1. Understand requirements and scope
2. Review the files identified by scout exploration
3. Design implementation approach following existing patterns
4. Create structured plan with:
   - Feature description and user story
   - Relevant files to modify/create
   - Step-by-step implementation tasks
   - Testing strategy
   - Acceptance criteria
   - Validation commands

Save plan to {{ config.paths.specs }}/ directory using relative path: {{ config.paths.specs }}/orch-plan-{timestamp}.md
Thoroughness level: medium
```

Wait for plan agent to complete.

If plan fails:
- Report error: "ERROR: Plan phase failed. Unable to create implementation plan."
- Show plan error details
- Show what scout phase completed successfully
- Mark plan todo as failed
- STOP - do not continue to build phase

Mark plan todo as completed, set build todo to `in_progress`.

### Step 5: Extract Plan Path and Launch Build Phase

Output progress message:
```
=== PHASE 3/4: BUILD ===
Implementing plan sequentially...
```

Parse plan agent output to extract:
- Path to saved plan file (should be in {{ config.paths.specs }}/ directory)

If plan file path not found:
- Report error: "ERROR: Plan file path not found in plan output."
- Mark build todo as failed
- STOP - do not continue to build phase

Launch build agent using Task tool:
- `subagent_type: "general-purpose"`
- `model: "sonnet"` (balanced for implementation)
- `description: "Build: sequential implementation"`
- `prompt`:
```
Implement the plan located at: {plan_file_path}

Follow the build workflow:
1. Read and parse the complete plan
2. Identify all implementation steps and dependencies
3. Execute each step sequentially:
   - Show clear progress (e.g., "Step 1/5: Creating models...")
   - Complete each step fully before moving to next
   - Verify each step works before proceeding
   - Use appropriate tools (Read, Write, Edit, Bash, etc.)
4. If any step fails:
   - STOP immediately
   - Report which step failed
   - Show what was completed successfully
5. After completion, report:
   - Implementation status (success or failure)
   - Steps completed
   - Changes made (git diff --stat)
   - Summary of implementation

Follow best practices and coding standards.
```

Wait for build agent to complete.

If build fails:
- Report error: "ERROR: Build phase failed during implementation."
- Show build error details
- Show what scout and plan phases completed successfully
- List steps completed before failure
- Mark build todo as failed
- STOP - do not continue to review phase

Mark build todo as completed, set review todo to `in_progress`.

### Step 6: Launch Review Phase

Output progress message:
```
=== PHASE 4/4: REVIEW ===
Conducting quality review of implementation...
```

Launch review agent using Task tool:
- `subagent_type: "general-purpose"`
- `model: "sonnet"` (thorough review)
- `description: "Review: quality assessment"`
- `prompt`:
```
Review the implementation that was just completed for: {TASK_DESCRIPTION}

Plan location: {plan_file_path}

Conduct comprehensive review:
1. Read the implementation plan to understand acceptance criteria
2. Review all changed files (use git diff to identify changes)
3. Assess code quality:
   - Best practices adherence
   - Code style consistency
   - Error handling
   - Documentation completeness
   - Test coverage
4. Validate against acceptance criteria from plan
5. Check for potential issues:
   - Security vulnerabilities
   - Performance concerns
   - Edge cases not handled
   - Missing error handling
6. Provide actionable feedback:
   - What works well
   - What needs improvement
   - Specific recommendations for fixes

Generate review report with:
- Overall assessment (Excellent/Good/Needs Improvement/Poor)
- Strengths of implementation
- Issues found (categorized by severity)
- Recommendations for improvement
- Validation status against acceptance criteria
```

Wait for review agent to complete.

If review fails:
- Report warning: "WARNING: Review phase failed. Implementation is complete but review could not be conducted."
- Show review error details
- Mark review todo as failed (non-blocking)

Mark review todo as completed.

### Step 7: Report Final Status

Output comprehensive completion report:

```
=== WORKFLOW COMPLETE ===

Status: [SUCCESS or FAILED at {phase}]

Phase Results:
- Scout Phase: ‚úì Complete (files discovered)
- Plan Phase: ‚úì Complete (Plan saved to {plan_path})
- Build Phase: [‚úì Complete or ‚úó Failed at step X/Y]
- Review Phase: [‚úì Complete or ‚úó Failed or ‚ö† Warning]

Implementation Summary:
{build_summary}

Review Assessment:
{review_summary}

Changes Made:
{git_diff_stat_output}

Next Steps:
- Run validation commands from the plan
- Address any issues identified in review
- Run tests with /test
- Create commit with /commit
```

## Report

Provide a structured report of the entire workflow execution:

### Execution Status
- Overall Status: [SUCCESS or FAILED]
- Failed Phase: [None or Scout/Plan/Build/Review]
- Completion: [4/4 phases or X/4 phases]

### Phase Details

**Scout Phase:**
- Status: [Complete/Failed]
- Files Discovered: {count}
- Relevant Files: {list or summary}

**Plan Phase:**
- Status: [Complete/Failed/Skipped]
- Plan File: {path or N/A}
- Steps Planned: {count or N/A}

**Build Phase:**
- Status: [Complete/Failed/Skipped]
- Steps Completed: {X/Y or N/A}
- Files Modified: {count or N/A}
- Lines Changed: {count or N/A}

**Review Phase:**
- Status: [Complete/Failed/Skipped]
- Overall Assessment: {rating or N/A}
- Issues Found: {count or N/A}
- Recommendations: {summary or N/A}

### Git Changes
```
{output of git diff --stat if build completed}
```

### Implementation Summary
- Bullet point list of what was implemented (if build completed)
- Any issues encountered and resolutions
- Review findings and recommendations

### Recommendations

If successful:
- Address any issues identified in review phase
- Run validation commands specified in the plan
- Run tests with `/test` before committing
- Create commit with `/commit` after validation

If failed:
- Review error messages for the failed phase
- Fix issues and retry the failed phase individually:
  - Scout failed: Retry with scout commands
  - Plan failed: Retry with `/plan` after reviewing scout results
  - Build failed: Fix issues and retry with `/build {plan_path}`
  - Review failed: Implementation is complete, review manually

### Notes
- This workflow provides end-to-end automation with quality assurance
- Scout-Plan-Build-Review requires clear task descriptions
- For complex tasks with uncertainty, consider running phases individually for better control
- Review phase is non-blocking - implementation succeeds even if review fails
