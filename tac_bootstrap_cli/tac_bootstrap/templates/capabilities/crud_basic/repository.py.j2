"""
IDK: repository, {{ config.entity.snake_name }}, data-access

Module: {{ config.entity.snake_name }}_repository

Responsibility:
- Provide data access for {{ config.entity.name }} entities
- Implement custom queries and filtering
- Abstract database operations

Key Components:
- {{ config.entity.name }}Repository: Data access layer for {{ config.entity.name }}

Related Docs:
- docs/{{ config.entity.capability }}/repositories/{{ config.entity.snake_name }}.md
"""

from sqlalchemy.orm import Session
from sqlalchemy import or_
from {{ config.config.project.name | replace("-", "_") }}.shared.repositories.base_repository import BaseRepository
from .orm_model import {{ config.entity.name }}Model
from typing import Optional, List


class {{ config.entity.name }}Repository(BaseRepository[{{ config.entity.name }}Model]):
    """
    IDK: repository, {{ config.entity.snake_name }}, crud

    Responsibility:
    - Manage {{ config.entity.name }} persistence
    - Provide custom query methods
    - Handle database transactions

    Invariants:
    - All queries respect soft delete (state != 2)
    - Session management delegated to BaseRepository

    Related Docs:
    - docs/{{ config.entity.capability }}/repositories/{{ config.entity.snake_name }}-queries.md
    """

    def __init__(self, session: Session):
        """
        IDK: initialization, dependency-injection

        Responsibility:
        - Initialize repository with database session

        Inputs:
        - session: SQLAlchemy database session

        Outputs:
        - None
        """
        super().__init__(session, {{ config.entity.name }}Model)

{% set indexed_fields = config.entity.fields | selectattr('indexed', 'equalto', true) | list %}
{% if indexed_fields %}
{% for field in indexed_fields %}
{% set type_map = {
    'str': 'str',
    'int': 'int',
    'float': 'float',
    'bool': 'bool',
    'datetime': 'datetime',
    'uuid': 'str',
    'text': 'str',
    'decimal': 'float',
    'json': 'dict'
} %}
    def get_by_{{ field.name }}(self, {{ field.name }}: {{ type_map[field.type] }}) -> Optional[{{ config.entity.name }}Model]:
        """
        IDK: query-method, {{ field.name }}-lookup

        Responsibility:
        - Get {{ config.entity.name }} by {{ field.name }}

        Inputs:
        - {{ field.name }}: {{ field.name | replace('_', ' ') | title }} to search for

        Outputs:
        - {{ config.entity.name }}Model if found, None otherwise

        Related Docs:
        - docs/{{ config.entity.capability }}/repositories/{{ config.entity.snake_name }}-queries.md
        """
        return self.session.query({{ config.entity.name }}Model).filter(
            {{ config.entity.name }}Model.{{ field.name }} == {{ field.name }}
        ).first()

{% endfor %}
{% endif %}
{% set string_fields = config.entity.fields | selectattr('type', 'in', ['str', 'text']) | list %}
{% if string_fields %}
    def search(self, query: str, skip: int = 0, limit: int = 100) -> List[{{ config.entity.name }}Model]:
        """
        IDK: search, text-query, filtering

        Responsibility:
        - Search {{ config.entity.name }} by text fields
        - Support pagination

        Inputs:
        - query: Search query string
        - skip: Number of records to skip (default: 0)
        - limit: Maximum records to return (default: 100)

        Outputs:
        - List of matching {{ config.entity.name }}Model instances

        Related Docs:
        - docs/{{ config.entity.capability }}/repositories/{{ config.entity.snake_name }}-search.md
        """
        filters = [
{% for field in string_fields %}
            {{ config.entity.name }}Model.{{ field.name }}.ilike(f"%{query}%"),
{% endfor %}
        ]
        return self.session.query({{ config.entity.name }}Model).filter(
            or_(*filters)
        ).offset(skip).limit(limit).all()
{% endif %}
