"""Orchestrator Web Backend - FastAPI Application.

Zero-configuration FastAPI server for orchestrating ADW workflows with SQLite.
Provides REST API (CQRS) + WebSocket for real-time agent status updates.

Serves the tac-14 frontend API surface at root level (no /api prefix)
for compatibility with orchestrator_3_stream frontend.
"""

import asyncio
import json
import sys
from contextlib import asynccontextmanager
from datetime import datetime
from pathlib import Path

import aiosqlite
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware

# Add adws directory to path for adw_modules import
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent / "adws"))

from adw_modules.adw_database import DatabaseManager
import dependencies
from config import DATABASE_PATH, CORS_ORIGINS, BACKEND_PORT
from routers import agents, runtime, websocket, compat
from routers.compat import _transform_agent


@asynccontextmanager
async def lifespan(app: FastAPI):
    """FastAPI lifespan manager - connects DatabaseManager on startup."""
    # Startup
    db_path = dependencies.get_database_path()
    db_path.parent.mkdir(parents=True, exist_ok=True)

    print(f"[Orchestrator] Connecting to database: {db_path}")
    dependencies.db_manager = DatabaseManager(str(db_path))
    await dependencies.db_manager.connect()
    print("[Orchestrator] Database connected successfully")

    yield

    # Shutdown
    print("[Orchestrator] Closing database connection")
    await dependencies.db_manager.close()
    print("[Orchestrator] Shutdown complete")


# Create FastAPI app with lifespan
app = FastAPI(
    title="Orchestrator Web Backend",
    description="FastAPI backend for TAC Bootstrap agent orchestration",
    version="0.9.6",
    lifespan=lifespan,
)

# Configure CORS for Web UI (origins loaded from config.yml)
app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Register routers
# Original CQRS routers under /api prefix
app.include_router(agents.router, prefix="/api", tags=["Agents"])
app.include_router(runtime.router, prefix="/api", tags=["Runtime"])
app.include_router(websocket.router, prefix="/ws", tags=["WebSocket (Legacy)"])

# TAC-14 compatible router at root level (no prefix)
app.include_router(compat.router, tags=["TAC-14 Compatible"])


@app.get("/")
async def root():
    """Health check endpoint."""
    return {
        "service": "orchestrator-web",
        "version": "0.9.6",
        "status": "operational"
    }


@app.get("/health")
async def health():
    """Detailed health check with database status."""
    db_manager = dependencies.get_db_manager()
    return {
        "status": "healthy",
        "service": "orchestrator-web",
        "database": "connected" if db_manager.conn else "disconnected",
        "database_path": str(dependencies.get_database_path()),
        "websocket_connections": len(_ws_connections),
    }


# ═══════════════════════════════════════════════════════════
# WEBSOCKET at /ws (TAC-14 compatible)
# ═══════════════════════════════════════════════════════════

_ws_connections: list[WebSocket] = []


async def _broadcast_to_all(data: dict, exclude: WebSocket | None = None):
    """Broadcast a message to all connected WebSocket clients."""
    if "timestamp" not in data:
        data["timestamp"] = datetime.now().isoformat()

    disconnected = []
    for ws in _ws_connections:
        if ws == exclude:
            continue
        try:
            await ws.send_json(data)
        except Exception:
            disconnected.append(ws)

    for ws in disconnected:
        if ws in _ws_connections:
            _ws_connections.remove(ws)


async def _fetch_adw_workflows() -> list[dict]:
    """Fetch current ADW workflows from SQLite."""
    try:
        async with aiosqlite.connect(DATABASE_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT * FROM ai_developer_workflows ORDER BY created_at DESC LIMIT 20"
            )
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    except Exception as e:
        print(f"[WS] DB error fetching ADWs: {e}")
        return []


async def _fetch_agents() -> list[dict]:
    """Fetch current agents from SQLite, transformed to frontend format."""
    try:
        async with aiosqlite.connect(DATABASE_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT * FROM agents ORDER BY started_at DESC LIMIT 50"
            )
            rows = await cursor.fetchall()
            return [_transform_agent(dict(row)) for row in rows]
    except Exception as e:
        print(f"[WS] DB error fetching agents: {e}")
        return []


async def _send_initial_state(websocket: WebSocket):
    """Send all existing ADWs and agents to a newly connected client."""
    # Send ADWs
    workflows = await _fetch_adw_workflows()
    for wf in workflows:
        try:
            await websocket.send_json({
                "type": "adw_created",
                "adw": wf,
                "timestamp": datetime.now().isoformat(),
            })
        except Exception:
            return

    # Send agents
    agents = await _fetch_agents()
    for agent in agents:
        try:
            await websocket.send_json({
                "type": "agent_created",
                "agent": agent,
                "timestamp": datetime.now().isoformat(),
            })
        except Exception:
            return


async def _poll_changes():
    """Background task that polls SQLite for ADW and agent changes."""
    known_adw_ids: set[str] = set()
    known_agent_ids: set[str] = set()
    last_adw_snapshot = ""
    last_agent_snapshot = ""

    while True:
        try:
            # --- Poll ADW workflows ---
            workflows = await _fetch_adw_workflows()
            adw_snapshot = json.dumps(
                [(w.get("adw_name"), w.get("status"), w.get("current_step"),
                  w.get("completed_steps"), w.get("updated_at"))
                 for w in workflows],
                default=str,
            )

            if adw_snapshot != last_adw_snapshot and workflows:
                for wf in workflows:
                    adw_id = wf.get("id", wf.get("adw_name"))
                    if adw_id not in known_adw_ids:
                        known_adw_ids.add(adw_id)
                        await _broadcast_to_all({
                            "type": "adw_created",
                            "adw": wf,
                        })
                    else:
                        await _broadcast_to_all({
                            "type": "adw_updated",
                            "adw_id": adw_id,
                            "adw": wf,
                        })
                last_adw_snapshot = adw_snapshot

            # --- Poll agents ---
            agents = await _fetch_agents()
            agent_snapshot = json.dumps(
                [(a.get("id"), a.get("status"), a.get("completed_at"))
                 for a in agents],
                default=str,
            )

            if agent_snapshot != last_agent_snapshot and agents:
                for agent in agents:
                    agent_id = agent.get("id", "")
                    if agent_id not in known_agent_ids:
                        known_agent_ids.add(agent_id)
                        await _broadcast_to_all({
                            "type": "agent_created",
                            "agent": agent,
                        })
                    else:
                        await _broadcast_to_all({
                            "type": "agent_status_changed",
                            "agent_id": agent_id,
                            "old_status": "",
                            "new_status": agent.get("status", ""),
                        })
                last_agent_snapshot = agent_snapshot

        except Exception as e:
            print(f"[WS Poll] Error: {e}")

        await asyncio.sleep(2)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint compatible with tac-14 frontend chatService.

    Sends real-time ADW updates by polling SQLite every 2 seconds.
    Also handles incoming messages (adw_broadcast, agent_broadcast).
    """
    await websocket.accept()
    _ws_connections.append(websocket)

    client_id = f"client_{len(_ws_connections)}"
    print(f"[WS] Client connected: {client_id} (total: {len(_ws_connections)})")

    # Send welcome message
    await websocket.send_json({
        "type": "connection_established",
        "client_id": client_id,
        "timestamp": datetime.now().isoformat(),
        "message": "Connected to Orchestrator Backend (SQLite mode)",
    })

    # Send existing ADWs and agents so frontend populates stores immediately
    await _send_initial_state(websocket)

    # Start background poller
    poll_task = asyncio.create_task(_poll_changes())

    try:
        while True:
            data = await websocket.receive_text()
            if not data:
                continue

            try:
                message = json.loads(data)
                if not isinstance(message, dict) or "type" not in message:
                    continue

                msg_type = message.get("type")

                # Handle ADW broadcast requests (from workflow processes)
                if msg_type == "adw_broadcast":
                    broadcast_type = message.get("broadcast_type")
                    if broadcast_type == "adw_created":
                        await _broadcast_to_all(
                            {"type": "adw_created", "adw": message.get("adw", {})},
                            exclude=websocket,
                        )
                    elif broadcast_type == "adw_updated":
                        await _broadcast_to_all(
                            {"type": "adw_updated", "adw_id": message.get("adw_id", ""),
                             "adw": message.get("adw", {})},
                            exclude=websocket,
                        )
                    elif broadcast_type == "adw_event":
                        await _broadcast_to_all(
                            {"type": "adw_event", "adw_id": message.get("adw_id", ""),
                             "event": message.get("event", {})},
                            exclude=websocket,
                        )
                    elif broadcast_type == "adw_step_change":
                        await _broadcast_to_all(
                            {"type": "adw_step_change", "adw_id": message.get("adw_id", ""),
                             "step": message.get("step", ""),
                             "event_type": message.get("event_type", ""),
                             "payload": message.get("payload", {})},
                            exclude=websocket,
                        )
                    elif broadcast_type == "adw_status":
                        await _broadcast_to_all(
                            {"type": "adw_updated", "adw_id": message.get("adw_id", ""),
                             "adw": {
                                 "status": message.get("status"),
                                 "current_step": message.get("current_step"),
                                 "completed_steps": message.get("completed_steps"),
                                 "error_message": message.get("error_message"),
                             }},
                            exclude=websocket,
                        )

                # Handle agent broadcast requests
                elif msg_type == "agent_broadcast":
                    broadcast_type = message.get("broadcast_type")
                    if broadcast_type == "agent_created":
                        await _broadcast_to_all(
                            {"type": "agent_created", "agent": message.get("agent", {})},
                            exclude=websocket,
                        )
                    elif broadcast_type == "agent_status_changed":
                        await _broadcast_to_all(
                            {"type": "agent_status_changed",
                             "agent_id": message.get("agent_id", ""),
                             "old_status": message.get("old_status", ""),
                             "new_status": message.get("new_status", "")},
                            exclude=websocket,
                        )

            except json.JSONDecodeError:
                pass  # Plain text ping

    except WebSocketDisconnect:
        pass
    except Exception as e:
        print(f"[WS] Error: {e}")
    finally:
        poll_task.cancel()
        if websocket in _ws_connections:
            _ws_connections.remove(websocket)
        print(f"[WS] Client disconnected (total: {len(_ws_connections)})")


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=BACKEND_PORT,
        reload=True,
        log_level="info"
    )
